{"ast":null,"code":"// Defaults\nvar defaultOptions = {\n  format: 'image/png',\n  quality: 0.92,\n  width: undefined,\n  height: undefined,\n  Canvas: undefined,\n  crossOrigin: undefined\n}; // Return Promise\n\nvar mergeImages = function (sources, options) {\n  if (sources === void 0) sources = [];\n  if (options === void 0) options = {};\n  return new Promise(function (resolve) {\n    options = Object.assign({}, defaultOptions, options); // Setup browser/Node.js specific variables\n\n    var canvas = options.Canvas ? new options.Canvas() : window.document.createElement('canvas');\n    var Image = options.Image || window.Image; // Load sources\n\n    var images = sources.map(function (source) {\n      return new Promise(function (resolve, reject) {\n        // Convert sources to objects\n        if (source.constructor.name !== 'Object') {\n          source = {\n            src: source\n          };\n        } // Resolve source and img when loaded\n\n\n        var img = new Image();\n        img.crossOrigin = options.crossOrigin;\n\n        img.onerror = function () {\n          return reject(new Error('Couldn\\'t load image'));\n        };\n\n        img.onload = function () {\n          return resolve(Object.assign({}, source, {\n            img: img\n          }));\n        };\n\n        img.src = source.src;\n      });\n    }); // Get canvas context\n\n    var ctx = canvas.getContext('2d'); // When sources have loaded\n\n    resolve(Promise.all(images).then(function (images) {\n      // Set canvas dimensions\n      var getSize = function (dim) {\n        return options[dim] || Math.max.apply(Math, images.map(function (image) {\n          return image.img[dim];\n        }));\n      };\n\n      canvas.width = getSize('width');\n      canvas.height = getSize('height'); // Draw images to canvas\n\n      images.forEach(function (image) {\n        ctx.globalAlpha = image.opacity ? image.opacity : 1;\n        return ctx.drawImage(image.img, image.x || 0, image.y || 0);\n      });\n\n      if (options.Canvas && options.format === 'image/jpeg') {\n        // Resolve data URI for node-canvas jpeg async\n        return new Promise(function (resolve, reject) {\n          canvas.toDataURL(options.format, {\n            quality: options.quality,\n            progressive: false\n          }, function (err, jpeg) {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(jpeg);\n          });\n        });\n      } // Resolve all other data URIs sync\n\n\n      return canvas.toDataURL(options.format, options.quality);\n    }));\n  });\n};\n\nexport default mergeImages;","map":{"version":3,"sources":["/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/node_modules/merge-images/src/index.js"],"names":["const"],"mappings":"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","sourcesContent":["// Defaults\nconst defaultOptions = {\n\tformat: 'image/png',\n\tquality: 0.92,\n\twidth: undefined,\n\theight: undefined,\n\tCanvas: undefined,\n\tcrossOrigin: undefined\n};\n\n// Return Promise\nconst mergeImages = (sources = [], options = {}) => new Promise(resolve => {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\t// Setup browser/Node.js specific variables\n\tconst canvas = options.Canvas ? new options.Canvas() : window.document.createElement('canvas');\n\tconst Image = options.Image || window.Image;\n\n\t// Load sources\n\tconst images = sources.map(source => new Promise((resolve, reject) => {\n\t\t// Convert sources to objects\n\t\tif (source.constructor.name !== 'Object') {\n\t\t\tsource = { src: source };\n\t\t}\n\n\t\t// Resolve source and img when loaded\n\t\tconst img = new Image();\n\t\timg.crossOrigin = options.crossOrigin;\n\t\timg.onerror = () => reject(new Error('Couldn\\'t load image'));\n\t\timg.onload = () => resolve(Object.assign({}, source, { img }));\n\t\timg.src = source.src;\n\t}));\n\n\t// Get canvas context\n\tconst ctx = canvas.getContext('2d');\n\n\t// When sources have loaded\n\tresolve(Promise.all(images)\n\t\t.then(images => {\n\t\t\t// Set canvas dimensions\n\t\t\tconst getSize = dim => options[dim] || Math.max(...images.map(image => image.img[dim]));\n\t\t\tcanvas.width = getSize('width');\n\t\t\tcanvas.height = getSize('height');\n\n\t\t\t// Draw images to canvas\n\t\t\timages.forEach(image => {\n\t\t\t\tctx.globalAlpha = image.opacity ? image.opacity : 1;\n\t\t\t\treturn ctx.drawImage(image.img, image.x || 0, image.y || 0);\n\t\t\t});\n\n\t\t\tif (options.Canvas && options.format === 'image/jpeg') {\n\t\t\t\t// Resolve data URI for node-canvas jpeg async\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tcanvas.toDataURL(options.format, {\n\t\t\t\t\t\tquality: options.quality,\n\t\t\t\t\t\tprogressive: false\n\t\t\t\t\t}, (err, jpeg) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(jpeg);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Resolve all other data URIs sync\n\t\t\treturn canvas.toDataURL(options.format, options.quality);\n\t\t}));\n});\n\nexport default mergeImages;\n"]},"metadata":{},"sourceType":"module"}