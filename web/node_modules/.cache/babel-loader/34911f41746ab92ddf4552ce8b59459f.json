{"ast":null,"code":"'use strict';\n\nconst color = require('color');\n\nconst is = require('./is');\n/**\n * Rotate the output image by either an explicit angle\n * or auto-orient based on the EXIF `Orientation` tag.\n *\n * If an angle is provided, it is converted to a valid positive degree rotation.\n * For example, `-450` will produce a 270deg rotation.\n *\n * When rotating by an angle other than a multiple of 90,\n * the background colour can be provided with the `background` option.\n *\n * If no angle is provided, it is determined from the EXIF data.\n * Mirroring is supported and may infer the use of a flip operation.\n *\n * The use of `rotate` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * Method order is important when both rotating and extracting regions,\n * for example `rotate(x).extract(y)` will produce a different result to `extract(y).rotate(x)`.\n *\n * @example\n * const pipeline = sharp()\n *   .rotate()\n *   .resize(null, 200)\n *   .toBuffer(function (err, outputBuffer, info) {\n *     // outputBuffer contains 200px high JPEG image data,\n *     // auto-rotated using EXIF Orientation tag\n *     // info.width and info.height contain the dimensions of the resized image\n *   });\n * readableStream.pipe(pipeline);\n *\n * @param {number} [angle=auto] angle of rotation.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string|Object} [options.background=\"#000000\"] parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction rotate(angle, options) {\n  if (!is.defined(angle)) {\n    this.options.useExifOrientation = true;\n  } else if (is.integer(angle) && !(angle % 90)) {\n    this.options.angle = angle;\n  } else if (is.number(angle)) {\n    this.options.rotationAngle = angle;\n\n    if (is.object(options) && options.background) {\n      const backgroundColour = color(options.background);\n      this.options.rotationBackground = [backgroundColour.red(), backgroundColour.green(), backgroundColour.blue(), Math.round(backgroundColour.alpha() * 255)];\n    }\n  } else {\n    throw is.invalidParameterError('angle', 'numeric', angle);\n  }\n\n  return this;\n}\n/**\n * Flip the image about the vertical Y axis. This always occurs after rotation, if any.\n * The use of `flip` implies the removal of the EXIF `Orientation` tag, if any.\n * @param {Boolean} [flip=true]\n * @returns {Sharp}\n */\n\n\nfunction flip(flip) {\n  this.options.flip = is.bool(flip) ? flip : true;\n  return this;\n}\n/**\n * Flop the image about the horizontal X axis. This always occurs after rotation, if any.\n * The use of `flop` implies the removal of the EXIF `Orientation` tag, if any.\n * @param {Boolean} [flop=true]\n * @returns {Sharp}\n */\n\n\nfunction flop(flop) {\n  this.options.flop = is.bool(flop) ? flop : true;\n  return this;\n}\n/**\n * Perform an affine transform on an image. This operation will always occur after resizing, extraction and rotation, if any.\n *\n * You must provide an array of length 4 or a 2x2 affine transformation matrix.\n * By default, new pixels are filled with a black background. You can provide a background color with the `background` option.\n * A particular interpolator may also be specified. Set the `interpolator` option to an attribute of the `sharp.interpolator` Object e.g. `sharp.interpolator.nohalo`.\n *\n * In the case of a 2x2 matrix, the transform is:\n * - X = `matrix[0, 0]` \\* (x + `idx`) + `matrix[0, 1]` \\* (y + `idy`) + `odx`\n * - Y = `matrix[1, 0]` \\* (x + `idx`) + `matrix[1, 1]` \\* (y + `idy`) + `ody`\n *\n * where:\n * - x and y are the coordinates in input image.\n * - X and Y are the coordinates in output image.\n * - (0,0) is the upper left corner.\n *\n * @since 0.27.0\n *\n * @example\n * const pipeline = sharp()\n *   .affine([[1, 0.3], [0.1, 0.7]], {\n *      background: 'white',\n *      interpolate: sharp.interpolators.nohalo\n *   })\n *   .toBuffer((err, outputBuffer, info) => {\n *      // outputBuffer contains the transformed image\n *      // info.width and info.height contain the new dimensions\n *   });\n *\n * inputStream\n *   .pipe(pipeline);\n *\n * @param {Array<Array<number>>|Array<number>} matrix - affine transformation matrix\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {String|Object} [options.background=\"#000000\"] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Number} [options.idx=0] - input horizontal offset\n * @param {Number} [options.idy=0] - input vertical offset\n * @param {Number} [options.odx=0] - output horizontal offset\n * @param {Number} [options.ody=0] - output vertical offset\n * @param {String} [options.interpolator=sharp.interpolators.bicubic] - interpolator\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction affine(matrix, options) {\n  const flatMatrix = [].concat(...matrix);\n\n  if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {\n    this.options.affineMatrix = flatMatrix;\n  } else {\n    throw is.invalidParameterError('matrix', '1x4 or 2x2 array', matrix);\n  }\n\n  if (is.defined(options)) {\n    if (is.object(options)) {\n      this._setBackgroundColourOption('affineBackground', options.background);\n\n      if (is.defined(options.idx)) {\n        if (is.number(options.idx)) {\n          this.options.affineIdx = options.idx;\n        } else {\n          throw is.invalidParameterError('options.idx', 'number', options.idx);\n        }\n      }\n\n      if (is.defined(options.idy)) {\n        if (is.number(options.idy)) {\n          this.options.affineIdy = options.idy;\n        } else {\n          throw is.invalidParameterError('options.idy', 'number', options.idy);\n        }\n      }\n\n      if (is.defined(options.odx)) {\n        if (is.number(options.odx)) {\n          this.options.affineOdx = options.odx;\n        } else {\n          throw is.invalidParameterError('options.odx', 'number', options.odx);\n        }\n      }\n\n      if (is.defined(options.ody)) {\n        if (is.number(options.ody)) {\n          this.options.affineOdy = options.ody;\n        } else {\n          throw is.invalidParameterError('options.ody', 'number', options.ody);\n        }\n      }\n\n      if (is.defined(options.interpolator)) {\n        if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n          this.options.affineInterpolator = options.interpolator;\n        } else {\n          throw is.invalidParameterError('options.interpolator', 'valid interpolator name', options.interpolator);\n        }\n      }\n    } else {\n      throw is.invalidParameterError('options', 'object', options);\n    }\n  }\n\n  return this;\n}\n/**\n * Sharpen the image.\n * When used without parameters, performs a fast, mild sharpen of the output image.\n * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.\n * Separate control over the level of sharpening in \"flat\" and \"jagged\" areas is available.\n *\n * @param {number} [sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @param {number} [flat=1.0] - the level of sharpening to apply to \"flat\" areas.\n * @param {number} [jagged=2.0] - the level of sharpening to apply to \"jagged\" areas.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction sharpen(sigma, flat, jagged) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild sharpen\n    this.options.sharpenSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild sharpen?\n    this.options.sharpenSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.01, 10000)) {\n    // Numeric argument: specific sigma\n    this.options.sharpenSigma = sigma; // Control over flat areas\n\n    if (is.defined(flat)) {\n      if (is.number(flat) && is.inRange(flat, 0, 10000)) {\n        this.options.sharpenFlat = flat;\n      } else {\n        throw is.invalidParameterError('flat', 'number between 0 and 10000', flat);\n      }\n    } // Control over jagged areas\n\n\n    if (is.defined(jagged)) {\n      if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {\n        this.options.sharpenJagged = jagged;\n      } else {\n        throw is.invalidParameterError('jagged', 'number between 0 and 10000', jagged);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.01 and 10000', sigma);\n  }\n\n  return this;\n}\n/**\n * Apply median filter.\n * When used without parameters the default window is 3x3.\n * @param {number} [size=3] square mask size: size x size\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction median(size) {\n  if (!is.defined(size)) {\n    // No arguments: default to 3x3\n    this.options.medianSize = 3;\n  } else if (is.integer(size) && is.inRange(size, 1, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.medianSize = size;\n  } else {\n    throw is.invalidParameterError('size', 'integer between 1 and 1000', size);\n  }\n\n  return this;\n}\n/**\n * Blur the image.\n * When used without parameters, performs a fast, mild blur of the output image.\n * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.\n * @param {number} [sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction blur(sigma) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild blur\n    this.options.blurSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild blur?\n    this.options.blurSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.blurSigma = sigma;\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.3 and 1000', sigma);\n  }\n\n  return this;\n}\n/**\n * Merge alpha transparency channel, if any, with a background, then remove the alpha channel.\n *\n * See also {@link /api-channel#removealpha|removeAlpha}.\n *\n * @example\n * await sharp(rgbaInput)\n *   .flatten({ background: '#F0A703' })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {string|Object} [options.background={r: 0, g: 0, b: 0}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black.\n * @returns {Sharp}\n */\n\n\nfunction flatten(options) {\n  this.options.flatten = is.bool(options) ? options : true;\n\n  if (is.object(options)) {\n    this._setBackgroundColourOption('flattenBackground', options.background);\n  }\n\n  return this;\n}\n/**\n * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`\n * then increasing the encoding (brighten) post-resize at a factor of `gamma`.\n * This can improve the perceived brightness of a resized image in non-linear colour spaces.\n * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation\n * when applying a gamma correction.\n *\n * Supply a second argument to use a different output gamma value, otherwise the first value is used in both cases.\n *\n * @param {number} [gamma=2.2] value between 1.0 and 3.0.\n * @param {number} [gammaOut] value between 1.0 and 3.0. (optional, defaults to same as `gamma`)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction gamma(gamma, gammaOut) {\n  if (!is.defined(gamma)) {\n    // Default gamma correction of 2.2 (sRGB)\n    this.options.gamma = 2.2;\n  } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {\n    this.options.gamma = gamma;\n  } else {\n    throw is.invalidParameterError('gamma', 'number between 1.0 and 3.0', gamma);\n  }\n\n  if (!is.defined(gammaOut)) {\n    // Default gamma correction for output is same as input\n    this.options.gammaOut = this.options.gamma;\n  } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {\n    this.options.gammaOut = gammaOut;\n  } else {\n    throw is.invalidParameterError('gammaOut', 'number between 1.0 and 3.0', gammaOut);\n  }\n\n  return this;\n}\n/**\n * Produce the \"negative\" of the image.\n * @param {Object} [options]\n * @param {Boolean} [options.alpha=true] Whether or not to negate any alpha channel\n * @returns {Sharp}\n */\n\n\nfunction negate(options) {\n  this.options.negate = is.bool(options) ? options : true;\n\n  if (is.plainObject(options) && 'alpha' in options) {\n    if (!is.bool(options.alpha)) {\n      throw is.invalidParameterError('alpha', 'should be boolean value', options.alpha);\n    } else {\n      this.options.negateAlpha = options.alpha;\n    }\n  }\n\n  return this;\n}\n/**\n * Enhance output image contrast by stretching its luminance to cover the full dynamic range.\n * @param {Boolean} [normalise=true]\n * @returns {Sharp}\n */\n\n\nfunction normalise(normalise) {\n  this.options.normalise = is.bool(normalise) ? normalise : true;\n  return this;\n}\n/**\n * Alternative spelling of normalise.\n * @param {Boolean} [normalize=true]\n * @returns {Sharp}\n */\n\n\nfunction normalize(normalize) {\n  return this.normalise(normalize);\n}\n/**\n * Perform contrast limiting adaptive histogram equalization\n * {@link https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE|CLAHE}.\n *\n * This will, in general, enhance the clarity of the image by bringing out darker details.\n *\n * @since 0.28.3\n *\n * @param {Object} options\n * @param {number} options.width - integer width of the region in pixels.\n * @param {number} options.height - integer height of the region in pixels.\n * @param {number} [options.maxSlope=3] - maximum value for the slope of the\n *  cumulative histogram. A value of 0 disables contrast limiting. Valid values\n *  are integers in the range 0-100 (inclusive)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction clahe(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n\n  if (!('width' in options) || !is.integer(options.width) || options.width <= 0) {\n    throw is.invalidParameterError('width', 'integer above zero', options.width);\n  } else {\n    this.options.claheWidth = options.width;\n  }\n\n  if (!('height' in options) || !is.integer(options.height) || options.height <= 0) {\n    throw is.invalidParameterError('height', 'integer above zero', options.height);\n  } else {\n    this.options.claheHeight = options.height;\n  }\n\n  if (!is.defined(options.maxSlope)) {\n    this.options.claheMaxSlope = 3;\n  } else if (!is.integer(options.maxSlope) || options.maxSlope < 0 || options.maxSlope > 100) {\n    throw is.invalidParameterError('maxSlope', 'integer 0-100', options.maxSlope);\n  } else {\n    this.options.claheMaxSlope = options.maxSlope;\n  }\n\n  return this;\n}\n/**\n * Convolve the image with the specified kernel.\n *\n * @example\n * sharp(input)\n *   .convolve({\n *     width: 3,\n *     height: 3,\n *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n *   })\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data representing the convolution\n *     // of the input image with the horizontal Sobel operator\n *   });\n *\n * @param {Object} kernel\n * @param {number} kernel.width - width of the kernel in pixels.\n * @param {number} kernel.height - height of the kernel in pixels.\n * @param {Array<number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n * @param {number} [kernel.scale=sum] - the scale of the kernel in pixels.\n * @param {number} [kernel.offset=0] - the offset of the kernel in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction convolve(kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  } // Default scale is sum of kernel values\n\n\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  } // Clip scale to a minimum value of 1\n\n\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n\n  this.options.convKernel = kernel;\n  return this;\n}\n/**\n * Any pixel value greater than or equal to the threshold value will be set to 255, otherwise it will be set to 0.\n * @param {number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.\n * @param {Object} [options]\n * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.\n * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction threshold(threshold, options) {\n  if (!is.defined(threshold)) {\n    this.options.threshold = 128;\n  } else if (is.bool(threshold)) {\n    this.options.threshold = threshold ? 128 : 0;\n  } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {\n    this.options.threshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'integer between 0 and 255', threshold);\n  }\n\n  if (!is.object(options) || options.greyscale === true || options.grayscale === true) {\n    this.options.thresholdGrayscale = true;\n  } else {\n    this.options.thresholdGrayscale = false;\n  }\n\n  return this;\n}\n/**\n * Perform a bitwise boolean operation with operand image.\n *\n * This operation creates an output image where each pixel is the result of\n * the selected bitwise boolean `operation` between the corresponding pixels of the input images.\n *\n * @param {Buffer|string} operand - Buffer containing image data or string containing the path to an image file.\n * @param {string} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @param {Object} [options]\n * @param {Object} [options.raw] - describes operand when using raw pixel data.\n * @param {number} [options.raw.width]\n * @param {number} [options.raw.height]\n * @param {number} [options.raw.channels]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction boolean(operand, operator, options) {\n  this.options.boolean = this._createInputDescriptor(operand, options);\n\n  if (is.string(operator) && is.inArray(operator, ['and', 'or', 'eor'])) {\n    this.options.booleanOp = operator;\n  } else {\n    throw is.invalidParameterError('operator', 'one of: and, or, eor', operator);\n  }\n\n  return this;\n}\n/**\n * Apply the linear formula a * input + b to the image (levels adjustment)\n * @param {number} [a=1.0] multiplier\n * @param {number} [b=0.0] offset\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction linear(a, b) {\n  if (!is.defined(a)) {\n    this.options.linearA = 1.0;\n  } else if (is.number(a)) {\n    this.options.linearA = a;\n  } else {\n    throw is.invalidParameterError('a', 'numeric', a);\n  }\n\n  if (!is.defined(b)) {\n    this.options.linearB = 0.0;\n  } else if (is.number(b)) {\n    this.options.linearB = b;\n  } else {\n    throw is.invalidParameterError('b', 'numeric', b);\n  }\n\n  return this;\n}\n/**\n * Recomb the image with the specified matrix.\n *\n * @since 0.21.1\n *\n * @example\n * sharp(input)\n *   .recomb([\n *    [0.3588, 0.7044, 0.1368],\n *    [0.2990, 0.5870, 0.1140],\n *    [0.2392, 0.4696, 0.0912],\n *   ])\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data after applying the recomb\n *     // With this example input, a sepia filter has been applied\n *   });\n *\n * @param {Array<Array<number>>} inputMatrix - 3x3 Recombination matrix\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction recomb(inputMatrix) {\n  if (!Array.isArray(inputMatrix) || inputMatrix.length !== 3 || inputMatrix[0].length !== 3 || inputMatrix[1].length !== 3 || inputMatrix[2].length !== 3) {\n    // must pass in a kernel\n    throw new Error('Invalid recombination matrix');\n  }\n\n  this.options.recombMatrix = [inputMatrix[0][0], inputMatrix[0][1], inputMatrix[0][2], inputMatrix[1][0], inputMatrix[1][1], inputMatrix[1][2], inputMatrix[2][0], inputMatrix[2][1], inputMatrix[2][2]].map(Number);\n  return this;\n}\n/**\n * Transforms the image using brightness, saturation, hue rotation, and lightness.\n * Brightness and lightness both operate on luminance, with the difference being that\n * brightness is multiplicative whereas lightness is additive.\n *\n * @since 0.22.1\n *\n * @example\n * sharp(input)\n *   .modulate({\n *     brightness: 2 // increase brightness by a factor of 2\n *   });\n *\n * sharp(input)\n *   .modulate({\n *     hue: 180 // hue-rotate by 180 degrees\n *   });\n *\n * sharp(input)\n *   .modulate({\n *     lightness: 50 // increase lightness by +50\n *   });\n *\n * // decreate brightness and saturation while also hue-rotating by 90 degrees\n * sharp(input)\n *   .modulate({\n *     brightness: 0.5,\n *     saturation: 0.5,\n *     hue: 90\n *   });\n *\n * @param {Object} [options]\n * @param {number} [options.brightness] Brightness multiplier\n * @param {number} [options.saturation] Saturation multiplier\n * @param {number} [options.hue] Degrees for hue rotation\n * @param {number} [options.lightness] Lightness addend\n * @returns {Sharp}\n */\n\n\nfunction modulate(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n\n  if ('brightness' in options) {\n    if (is.number(options.brightness) && options.brightness >= 0) {\n      this.options.brightness = options.brightness;\n    } else {\n      throw is.invalidParameterError('brightness', 'number above zero', options.brightness);\n    }\n  }\n\n  if ('saturation' in options) {\n    if (is.number(options.saturation) && options.saturation >= 0) {\n      this.options.saturation = options.saturation;\n    } else {\n      throw is.invalidParameterError('saturation', 'number above zero', options.saturation);\n    }\n  }\n\n  if ('hue' in options) {\n    if (is.integer(options.hue)) {\n      this.options.hue = options.hue % 360;\n    } else {\n      throw is.invalidParameterError('hue', 'number', options.hue);\n    }\n  }\n\n  if ('lightness' in options) {\n    if (is.number(options.lightness)) {\n      this.options.lightness = options.lightness;\n    } else {\n      throw is.invalidParameterError('lightness', 'number', options.lightness);\n    }\n  }\n\n  return this;\n}\n/**\n * Decorate the Sharp prototype with operation-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    rotate,\n    flip,\n    flop,\n    affine,\n    sharpen,\n    median,\n    blur,\n    flatten,\n    gamma,\n    negate,\n    normalise,\n    normalize,\n    clahe,\n    convolve,\n    threshold,\n    boolean,\n    linear,\n    recomb,\n    modulate\n  });\n};","map":{"version":3,"sources":["/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/node_modules/sharp/lib/operation.js"],"names":["color","require","is","rotate","angle","options","defined","useExifOrientation","integer","number","rotationAngle","object","background","backgroundColour","rotationBackground","red","green","blue","Math","round","alpha","invalidParameterError","flip","bool","flop","affine","matrix","flatMatrix","concat","length","every","affineMatrix","_setBackgroundColourOption","idx","affineIdx","idy","affineIdy","odx","affineOdx","ody","affineOdy","interpolator","inArray","Object","values","constructor","interpolators","affineInterpolator","sharpen","sigma","flat","jagged","sharpenSigma","inRange","sharpenFlat","sharpenJagged","median","size","medianSize","blur","blurSigma","flatten","gamma","gammaOut","negate","plainObject","negateAlpha","normalise","normalize","clahe","width","claheWidth","height","claheHeight","maxSlope","claheMaxSlope","convolve","kernel","Array","isArray","Error","scale","reduce","a","b","offset","convKernel","threshold","greyscale","grayscale","thresholdGrayscale","boolean","operand","operator","_createInputDescriptor","string","booleanOp","linear","linearA","linearB","recomb","inputMatrix","recombMatrix","map","Number","modulate","brightness","saturation","hue","lightness","module","exports","Sharp","assign","prototype"],"mappings":"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","sourcesContent":["'use strict';\n\nconst color = require('color');\nconst is = require('./is');\n\n/**\n * Rotate the output image by either an explicit angle\n * or auto-orient based on the EXIF `Orientation` tag.\n *\n * If an angle is provided, it is converted to a valid positive degree rotation.\n * For example, `-450` will produce a 270deg rotation.\n *\n * When rotating by an angle other than a multiple of 90,\n * the background colour can be provided with the `background` option.\n *\n * If no angle is provided, it is determined from the EXIF data.\n * Mirroring is supported and may infer the use of a flip operation.\n *\n * The use of `rotate` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * Method order is important when both rotating and extracting regions,\n * for example `rotate(x).extract(y)` will produce a different result to `extract(y).rotate(x)`.\n *\n * @example\n * const pipeline = sharp()\n *   .rotate()\n *   .resize(null, 200)\n *   .toBuffer(function (err, outputBuffer, info) {\n *     // outputBuffer contains 200px high JPEG image data,\n *     // auto-rotated using EXIF Orientation tag\n *     // info.width and info.height contain the dimensions of the resized image\n *   });\n * readableStream.pipe(pipeline);\n *\n * @param {number} [angle=auto] angle of rotation.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string|Object} [options.background=\"#000000\"] parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction rotate (angle, options) {\n  if (!is.defined(angle)) {\n    this.options.useExifOrientation = true;\n  } else if (is.integer(angle) && !(angle % 90)) {\n    this.options.angle = angle;\n  } else if (is.number(angle)) {\n    this.options.rotationAngle = angle;\n    if (is.object(options) && options.background) {\n      const backgroundColour = color(options.background);\n      this.options.rotationBackground = [\n        backgroundColour.red(),\n        backgroundColour.green(),\n        backgroundColour.blue(),\n        Math.round(backgroundColour.alpha() * 255)\n      ];\n    }\n  } else {\n    throw is.invalidParameterError('angle', 'numeric', angle);\n  }\n  return this;\n}\n\n/**\n * Flip the image about the vertical Y axis. This always occurs after rotation, if any.\n * The use of `flip` implies the removal of the EXIF `Orientation` tag, if any.\n * @param {Boolean} [flip=true]\n * @returns {Sharp}\n */\nfunction flip (flip) {\n  this.options.flip = is.bool(flip) ? flip : true;\n  return this;\n}\n\n/**\n * Flop the image about the horizontal X axis. This always occurs after rotation, if any.\n * The use of `flop` implies the removal of the EXIF `Orientation` tag, if any.\n * @param {Boolean} [flop=true]\n * @returns {Sharp}\n */\nfunction flop (flop) {\n  this.options.flop = is.bool(flop) ? flop : true;\n  return this;\n}\n\n/**\n * Perform an affine transform on an image. This operation will always occur after resizing, extraction and rotation, if any.\n *\n * You must provide an array of length 4 or a 2x2 affine transformation matrix.\n * By default, new pixels are filled with a black background. You can provide a background color with the `background` option.\n * A particular interpolator may also be specified. Set the `interpolator` option to an attribute of the `sharp.interpolator` Object e.g. `sharp.interpolator.nohalo`.\n *\n * In the case of a 2x2 matrix, the transform is:\n * - X = `matrix[0, 0]` \\* (x + `idx`) + `matrix[0, 1]` \\* (y + `idy`) + `odx`\n * - Y = `matrix[1, 0]` \\* (x + `idx`) + `matrix[1, 1]` \\* (y + `idy`) + `ody`\n *\n * where:\n * - x and y are the coordinates in input image.\n * - X and Y are the coordinates in output image.\n * - (0,0) is the upper left corner.\n *\n * @since 0.27.0\n *\n * @example\n * const pipeline = sharp()\n *   .affine([[1, 0.3], [0.1, 0.7]], {\n *      background: 'white',\n *      interpolate: sharp.interpolators.nohalo\n *   })\n *   .toBuffer((err, outputBuffer, info) => {\n *      // outputBuffer contains the transformed image\n *      // info.width and info.height contain the new dimensions\n *   });\n *\n * inputStream\n *   .pipe(pipeline);\n *\n * @param {Array<Array<number>>|Array<number>} matrix - affine transformation matrix\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {String|Object} [options.background=\"#000000\"] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Number} [options.idx=0] - input horizontal offset\n * @param {Number} [options.idy=0] - input vertical offset\n * @param {Number} [options.odx=0] - output horizontal offset\n * @param {Number} [options.ody=0] - output vertical offset\n * @param {String} [options.interpolator=sharp.interpolators.bicubic] - interpolator\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction affine (matrix, options) {\n  const flatMatrix = [].concat(...matrix);\n  if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {\n    this.options.affineMatrix = flatMatrix;\n  } else {\n    throw is.invalidParameterError('matrix', '1x4 or 2x2 array', matrix);\n  }\n\n  if (is.defined(options)) {\n    if (is.object(options)) {\n      this._setBackgroundColourOption('affineBackground', options.background);\n      if (is.defined(options.idx)) {\n        if (is.number(options.idx)) {\n          this.options.affineIdx = options.idx;\n        } else {\n          throw is.invalidParameterError('options.idx', 'number', options.idx);\n        }\n      }\n      if (is.defined(options.idy)) {\n        if (is.number(options.idy)) {\n          this.options.affineIdy = options.idy;\n        } else {\n          throw is.invalidParameterError('options.idy', 'number', options.idy);\n        }\n      }\n      if (is.defined(options.odx)) {\n        if (is.number(options.odx)) {\n          this.options.affineOdx = options.odx;\n        } else {\n          throw is.invalidParameterError('options.odx', 'number', options.odx);\n        }\n      }\n      if (is.defined(options.ody)) {\n        if (is.number(options.ody)) {\n          this.options.affineOdy = options.ody;\n        } else {\n          throw is.invalidParameterError('options.ody', 'number', options.ody);\n        }\n      }\n      if (is.defined(options.interpolator)) {\n        if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n          this.options.affineInterpolator = options.interpolator;\n        } else {\n          throw is.invalidParameterError('options.interpolator', 'valid interpolator name', options.interpolator);\n        }\n      }\n    } else {\n      throw is.invalidParameterError('options', 'object', options);\n    }\n  }\n\n  return this;\n}\n\n/**\n * Sharpen the image.\n * When used without parameters, performs a fast, mild sharpen of the output image.\n * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.\n * Separate control over the level of sharpening in \"flat\" and \"jagged\" areas is available.\n *\n * @param {number} [sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @param {number} [flat=1.0] - the level of sharpening to apply to \"flat\" areas.\n * @param {number} [jagged=2.0] - the level of sharpening to apply to \"jagged\" areas.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction sharpen (sigma, flat, jagged) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild sharpen\n    this.options.sharpenSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild sharpen?\n    this.options.sharpenSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.01, 10000)) {\n    // Numeric argument: specific sigma\n    this.options.sharpenSigma = sigma;\n    // Control over flat areas\n    if (is.defined(flat)) {\n      if (is.number(flat) && is.inRange(flat, 0, 10000)) {\n        this.options.sharpenFlat = flat;\n      } else {\n        throw is.invalidParameterError('flat', 'number between 0 and 10000', flat);\n      }\n    }\n    // Control over jagged areas\n    if (is.defined(jagged)) {\n      if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {\n        this.options.sharpenJagged = jagged;\n      } else {\n        throw is.invalidParameterError('jagged', 'number between 0 and 10000', jagged);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.01 and 10000', sigma);\n  }\n  return this;\n}\n\n/**\n * Apply median filter.\n * When used without parameters the default window is 3x3.\n * @param {number} [size=3] square mask size: size x size\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction median (size) {\n  if (!is.defined(size)) {\n    // No arguments: default to 3x3\n    this.options.medianSize = 3;\n  } else if (is.integer(size) && is.inRange(size, 1, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.medianSize = size;\n  } else {\n    throw is.invalidParameterError('size', 'integer between 1 and 1000', size);\n  }\n  return this;\n}\n\n/**\n * Blur the image.\n * When used without parameters, performs a fast, mild blur of the output image.\n * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.\n * @param {number} [sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction blur (sigma) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild blur\n    this.options.blurSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild blur?\n    this.options.blurSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.blurSigma = sigma;\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.3 and 1000', sigma);\n  }\n  return this;\n}\n\n/**\n * Merge alpha transparency channel, if any, with a background, then remove the alpha channel.\n *\n * See also {@link /api-channel#removealpha|removeAlpha}.\n *\n * @example\n * await sharp(rgbaInput)\n *   .flatten({ background: '#F0A703' })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {string|Object} [options.background={r: 0, g: 0, b: 0}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black.\n * @returns {Sharp}\n */\nfunction flatten (options) {\n  this.options.flatten = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    this._setBackgroundColourOption('flattenBackground', options.background);\n  }\n  return this;\n}\n\n/**\n * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`\n * then increasing the encoding (brighten) post-resize at a factor of `gamma`.\n * This can improve the perceived brightness of a resized image in non-linear colour spaces.\n * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation\n * when applying a gamma correction.\n *\n * Supply a second argument to use a different output gamma value, otherwise the first value is used in both cases.\n *\n * @param {number} [gamma=2.2] value between 1.0 and 3.0.\n * @param {number} [gammaOut] value between 1.0 and 3.0. (optional, defaults to same as `gamma`)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction gamma (gamma, gammaOut) {\n  if (!is.defined(gamma)) {\n    // Default gamma correction of 2.2 (sRGB)\n    this.options.gamma = 2.2;\n  } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {\n    this.options.gamma = gamma;\n  } else {\n    throw is.invalidParameterError('gamma', 'number between 1.0 and 3.0', gamma);\n  }\n  if (!is.defined(gammaOut)) {\n    // Default gamma correction for output is same as input\n    this.options.gammaOut = this.options.gamma;\n  } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {\n    this.options.gammaOut = gammaOut;\n  } else {\n    throw is.invalidParameterError('gammaOut', 'number between 1.0 and 3.0', gammaOut);\n  }\n  return this;\n}\n\n/**\n * Produce the \"negative\" of the image.\n * @param {Object} [options]\n * @param {Boolean} [options.alpha=true] Whether or not to negate any alpha channel\n * @returns {Sharp}\n */\nfunction negate (options) {\n  this.options.negate = is.bool(options) ? options : true;\n  if (is.plainObject(options) && 'alpha' in options) {\n    if (!is.bool(options.alpha)) {\n      throw is.invalidParameterError('alpha', 'should be boolean value', options.alpha);\n    } else {\n      this.options.negateAlpha = options.alpha;\n    }\n  }\n  return this;\n}\n\n/**\n * Enhance output image contrast by stretching its luminance to cover the full dynamic range.\n * @param {Boolean} [normalise=true]\n * @returns {Sharp}\n */\nfunction normalise (normalise) {\n  this.options.normalise = is.bool(normalise) ? normalise : true;\n  return this;\n}\n\n/**\n * Alternative spelling of normalise.\n * @param {Boolean} [normalize=true]\n * @returns {Sharp}\n */\nfunction normalize (normalize) {\n  return this.normalise(normalize);\n}\n\n/**\n * Perform contrast limiting adaptive histogram equalization\n * {@link https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE|CLAHE}.\n *\n * This will, in general, enhance the clarity of the image by bringing out darker details.\n *\n * @since 0.28.3\n *\n * @param {Object} options\n * @param {number} options.width - integer width of the region in pixels.\n * @param {number} options.height - integer height of the region in pixels.\n * @param {number} [options.maxSlope=3] - maximum value for the slope of the\n *  cumulative histogram. A value of 0 disables contrast limiting. Valid values\n *  are integers in the range 0-100 (inclusive)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction clahe (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  if (!('width' in options) || !is.integer(options.width) || options.width <= 0) {\n    throw is.invalidParameterError('width', 'integer above zero', options.width);\n  } else {\n    this.options.claheWidth = options.width;\n  }\n  if (!('height' in options) || !is.integer(options.height) || options.height <= 0) {\n    throw is.invalidParameterError('height', 'integer above zero', options.height);\n  } else {\n    this.options.claheHeight = options.height;\n  }\n  if (!is.defined(options.maxSlope)) {\n    this.options.claheMaxSlope = 3;\n  } else if (!is.integer(options.maxSlope) || options.maxSlope < 0 || options.maxSlope > 100) {\n    throw is.invalidParameterError('maxSlope', 'integer 0-100', options.maxSlope);\n  } else {\n    this.options.claheMaxSlope = options.maxSlope;\n  }\n  return this;\n}\n\n/**\n * Convolve the image with the specified kernel.\n *\n * @example\n * sharp(input)\n *   .convolve({\n *     width: 3,\n *     height: 3,\n *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n *   })\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data representing the convolution\n *     // of the input image with the horizontal Sobel operator\n *   });\n *\n * @param {Object} kernel\n * @param {number} kernel.width - width of the kernel in pixels.\n * @param {number} kernel.height - height of the kernel in pixels.\n * @param {Array<number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n * @param {number} [kernel.scale=sum] - the scale of the kernel in pixels.\n * @param {number} [kernel.offset=0] - the offset of the kernel in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction convolve (kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) ||\n      !is.integer(kernel.width) || !is.integer(kernel.height) ||\n      !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) ||\n      kernel.height * kernel.width !== kernel.kernel.length\n  ) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  }\n  // Default scale is sum of kernel values\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n  // Clip scale to a minimum value of 1\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n  this.options.convKernel = kernel;\n  return this;\n}\n\n/**\n * Any pixel value greater than or equal to the threshold value will be set to 255, otherwise it will be set to 0.\n * @param {number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.\n * @param {Object} [options]\n * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.\n * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction threshold (threshold, options) {\n  if (!is.defined(threshold)) {\n    this.options.threshold = 128;\n  } else if (is.bool(threshold)) {\n    this.options.threshold = threshold ? 128 : 0;\n  } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {\n    this.options.threshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'integer between 0 and 255', threshold);\n  }\n  if (!is.object(options) || options.greyscale === true || options.grayscale === true) {\n    this.options.thresholdGrayscale = true;\n  } else {\n    this.options.thresholdGrayscale = false;\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation with operand image.\n *\n * This operation creates an output image where each pixel is the result of\n * the selected bitwise boolean `operation` between the corresponding pixels of the input images.\n *\n * @param {Buffer|string} operand - Buffer containing image data or string containing the path to an image file.\n * @param {string} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @param {Object} [options]\n * @param {Object} [options.raw] - describes operand when using raw pixel data.\n * @param {number} [options.raw.width]\n * @param {number} [options.raw.height]\n * @param {number} [options.raw.channels]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction boolean (operand, operator, options) {\n  this.options.boolean = this._createInputDescriptor(operand, options);\n  if (is.string(operator) && is.inArray(operator, ['and', 'or', 'eor'])) {\n    this.options.booleanOp = operator;\n  } else {\n    throw is.invalidParameterError('operator', 'one of: and, or, eor', operator);\n  }\n  return this;\n}\n\n/**\n * Apply the linear formula a * input + b to the image (levels adjustment)\n * @param {number} [a=1.0] multiplier\n * @param {number} [b=0.0] offset\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction linear (a, b) {\n  if (!is.defined(a)) {\n    this.options.linearA = 1.0;\n  } else if (is.number(a)) {\n    this.options.linearA = a;\n  } else {\n    throw is.invalidParameterError('a', 'numeric', a);\n  }\n  if (!is.defined(b)) {\n    this.options.linearB = 0.0;\n  } else if (is.number(b)) {\n    this.options.linearB = b;\n  } else {\n    throw is.invalidParameterError('b', 'numeric', b);\n  }\n  return this;\n}\n\n/**\n * Recomb the image with the specified matrix.\n *\n * @since 0.21.1\n *\n * @example\n * sharp(input)\n *   .recomb([\n *    [0.3588, 0.7044, 0.1368],\n *    [0.2990, 0.5870, 0.1140],\n *    [0.2392, 0.4696, 0.0912],\n *   ])\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data after applying the recomb\n *     // With this example input, a sepia filter has been applied\n *   });\n *\n * @param {Array<Array<number>>} inputMatrix - 3x3 Recombination matrix\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction recomb (inputMatrix) {\n  if (!Array.isArray(inputMatrix) || inputMatrix.length !== 3 ||\n      inputMatrix[0].length !== 3 ||\n      inputMatrix[1].length !== 3 ||\n      inputMatrix[2].length !== 3\n  ) {\n    // must pass in a kernel\n    throw new Error('Invalid recombination matrix');\n  }\n  this.options.recombMatrix = [\n    inputMatrix[0][0], inputMatrix[0][1], inputMatrix[0][2],\n    inputMatrix[1][0], inputMatrix[1][1], inputMatrix[1][2],\n    inputMatrix[2][0], inputMatrix[2][1], inputMatrix[2][2]\n  ].map(Number);\n  return this;\n}\n\n/**\n * Transforms the image using brightness, saturation, hue rotation, and lightness.\n * Brightness and lightness both operate on luminance, with the difference being that\n * brightness is multiplicative whereas lightness is additive.\n *\n * @since 0.22.1\n *\n * @example\n * sharp(input)\n *   .modulate({\n *     brightness: 2 // increase brightness by a factor of 2\n *   });\n *\n * sharp(input)\n *   .modulate({\n *     hue: 180 // hue-rotate by 180 degrees\n *   });\n *\n * sharp(input)\n *   .modulate({\n *     lightness: 50 // increase lightness by +50\n *   });\n *\n * // decreate brightness and saturation while also hue-rotating by 90 degrees\n * sharp(input)\n *   .modulate({\n *     brightness: 0.5,\n *     saturation: 0.5,\n *     hue: 90\n *   });\n *\n * @param {Object} [options]\n * @param {number} [options.brightness] Brightness multiplier\n * @param {number} [options.saturation] Saturation multiplier\n * @param {number} [options.hue] Degrees for hue rotation\n * @param {number} [options.lightness] Lightness addend\n * @returns {Sharp}\n */\nfunction modulate (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  if ('brightness' in options) {\n    if (is.number(options.brightness) && options.brightness >= 0) {\n      this.options.brightness = options.brightness;\n    } else {\n      throw is.invalidParameterError('brightness', 'number above zero', options.brightness);\n    }\n  }\n  if ('saturation' in options) {\n    if (is.number(options.saturation) && options.saturation >= 0) {\n      this.options.saturation = options.saturation;\n    } else {\n      throw is.invalidParameterError('saturation', 'number above zero', options.saturation);\n    }\n  }\n  if ('hue' in options) {\n    if (is.integer(options.hue)) {\n      this.options.hue = options.hue % 360;\n    } else {\n      throw is.invalidParameterError('hue', 'number', options.hue);\n    }\n  }\n  if ('lightness' in options) {\n    if (is.number(options.lightness)) {\n      this.options.lightness = options.lightness;\n    } else {\n      throw is.invalidParameterError('lightness', 'number', options.lightness);\n    }\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with operation-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    rotate,\n    flip,\n    flop,\n    affine,\n    sharpen,\n    median,\n    blur,\n    flatten,\n    gamma,\n    negate,\n    normalise,\n    normalize,\n    clahe,\n    convolve,\n    threshold,\n    boolean,\n    linear,\n    recomb,\n    modulate\n  });\n};\n"]},"metadata":{},"sourceType":"script"}