{"ast":null,"code":"'use strict';\n\nconst is = require('./is');\n/**\n * Boolean operations for bandbool.\n * @private\n */\n\n\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * See also {@link /api-operation#flatten|flatten}.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\n\nfunction removeAlpha() {\n  this.options.removeAlpha = true;\n  return this;\n}\n/**\n * Ensure the output image has an alpha transparency channel.\n * If missing, the added alpha channel will have the specified\n * transparency level, defaulting to fully-opaque (1).\n * This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * // rgba.png will be a 4 channel image with a fully-opaque alpha channel\n * await sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png')\n *\n * @example\n * // rgba is a 4 channel image with a fully-transparent alpha channel\n * const rgba = await sharp(rgb)\n *   .ensureAlpha(0)\n *   .toBuffer();\n *\n * @param {number} [alpha=1] - alpha transparency level (0=fully-transparent, 1=fully-opaque)\n * @returns {Sharp}\n * @throws {Error} Invalid alpha transparency level\n */\n\n\nfunction ensureAlpha(alpha) {\n  if (is.defined(alpha)) {\n    if (is.number(alpha) && is.inRange(alpha, 0, 1)) {\n      this.options.ensureAlpha = alpha;\n    } else {\n      throw is.invalidParameterError('alpha', 'number between 0 and 1', alpha);\n    }\n  } else {\n    this.options.ensureAlpha = 1;\n  }\n\n  return this;\n}\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * // green.jpg is a greyscale image containing the green channel of the input\n * await sharp(input)\n *   .extractChannel('green')\n *   .toFile('green.jpg');\n *\n * @example\n * // red1 is the red value of the first pixel, red2 the second pixel etc.\n * const [red1, red2, ...] = await sharp(input)\n *   .extractChannel(0)\n *   .raw()\n *   .toBuffer();\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\n\n\nfunction extractChannel(channel) {\n  const channelMap = {\n    red: 0,\n    green: 1,\n    blue: 2,\n    alpha: 3\n  };\n\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n\n  return this.toColourspace('b-w');\n}\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction joinChannel(images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n\n  return this;\n}\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction bandbool(boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n\n  return this;\n}\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  }); // Class attributes\n\n  Sharp.bool = bool;\n};","map":{"version":3,"sources":["/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/node_modules/sharp/lib/channel.js"],"names":["is","require","bool","and","or","eor","removeAlpha","options","ensureAlpha","alpha","defined","number","inRange","invalidParameterError","extractChannel","channel","channelMap","red","green","blue","Object","keys","includes","integer","toColourspace","joinChannel","images","Array","isArray","forEach","image","joinChannelIn","push","_createInputDescriptor","bandbool","boolOp","string","inArray","bandBoolOp","module","exports","Sharp","assign","prototype"],"mappings":"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","sourcesContent":["'use strict';\n\nconst is = require('./is');\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * See also {@link /api-operation#flatten|flatten}.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction removeAlpha () {\n  this.options.removeAlpha = true;\n  return this;\n}\n\n/**\n * Ensure the output image has an alpha transparency channel.\n * If missing, the added alpha channel will have the specified\n * transparency level, defaulting to fully-opaque (1).\n * This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * // rgba.png will be a 4 channel image with a fully-opaque alpha channel\n * await sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png')\n *\n * @example\n * // rgba is a 4 channel image with a fully-transparent alpha channel\n * const rgba = await sharp(rgb)\n *   .ensureAlpha(0)\n *   .toBuffer();\n *\n * @param {number} [alpha=1] - alpha transparency level (0=fully-transparent, 1=fully-opaque)\n * @returns {Sharp}\n * @throws {Error} Invalid alpha transparency level\n */\nfunction ensureAlpha (alpha) {\n  if (is.defined(alpha)) {\n    if (is.number(alpha) && is.inRange(alpha, 0, 1)) {\n      this.options.ensureAlpha = alpha;\n    } else {\n      throw is.invalidParameterError('alpha', 'number between 0 and 1', alpha);\n    }\n  } else {\n    this.options.ensureAlpha = 1;\n  }\n  return this;\n}\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * // green.jpg is a greyscale image containing the green channel of the input\n * await sharp(input)\n *   .extractChannel('green')\n *   .toFile('green.jpg');\n *\n * @example\n * // red1 is the red value of the first pixel, red2 the second pixel etc.\n * const [red1, red2, ...] = await sharp(input)\n *   .extractChannel(0)\n *   .raw()\n *   .toBuffer();\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel (channel) {\n  const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n  return this.toColourspace('b-w');\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel (images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool (boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};\n"]},"metadata":{},"sourceType":"script"}