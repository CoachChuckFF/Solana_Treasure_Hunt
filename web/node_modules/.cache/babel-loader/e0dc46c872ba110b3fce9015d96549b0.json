{"ast":null,"code":"const colorString = require('color-string');\n\nconst convert = require('color-convert');\n\nconst _slice = [].slice;\nconst skippedModels = [// To be honest, I don't really feel like keyword belongs in color convert, but eh.\n'keyword', // Gray conflicts with some method names, and has its own method defined.\n'gray', // Shouldn't really be in color-convert either...\n'hex'];\nconst hashedModelKeys = {};\n\nfor (const model of Object.keys(convert)) {\n  hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;\n}\n\nconst limiters = {};\n\nfunction Color(object, model) {\n  if (!(this instanceof Color)) {\n    return new Color(object, model);\n  }\n\n  if (model && model in skippedModels) {\n    model = null;\n  }\n\n  if (model && !(model in convert)) {\n    throw new Error('Unknown model: ' + model);\n  }\n\n  let i;\n  let channels;\n\n  if (object == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    this.model = 'rgb';\n    this.color = [0, 0, 0];\n    this.valpha = 1;\n  } else if (object instanceof Color) {\n    this.model = object.model;\n    this.color = object.color.slice();\n    this.valpha = object.valpha;\n  } else if (typeof object === 'string') {\n    const result = colorString.get(object);\n\n    if (result === null) {\n      throw new Error('Unable to parse color from string: ' + object);\n    }\n\n    this.model = result.model;\n    channels = convert[this.model].channels;\n    this.color = result.value.slice(0, channels);\n    this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n  } else if (object.length > 0) {\n    this.model = model || 'rgb';\n    channels = convert[this.model].channels;\n\n    const newArray = _slice.call(object, 0, channels);\n\n    this.color = zeroArray(newArray, channels);\n    this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;\n  } else if (typeof object === 'number') {\n    // This is always RGB - can be converted later on.\n    this.model = 'rgb';\n    this.color = [object >> 16 & 0xFF, object >> 8 & 0xFF, object & 0xFF];\n    this.valpha = 1;\n  } else {\n    this.valpha = 1;\n    const keys = Object.keys(object);\n\n    if ('alpha' in object) {\n      keys.splice(keys.indexOf('alpha'), 1);\n      this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;\n    }\n\n    const hashedKeys = keys.sort().join('');\n\n    if (!(hashedKeys in hashedModelKeys)) {\n      throw new Error('Unable to parse color from object: ' + JSON.stringify(object));\n    }\n\n    this.model = hashedModelKeys[hashedKeys];\n    const labels = convert[this.model].labels;\n    const color = [];\n\n    for (i = 0; i < labels.length; i++) {\n      color.push(object[labels[i]]);\n    }\n\n    this.color = zeroArray(color);\n  } // Perform limitations (clamping, etc.)\n\n\n  if (limiters[this.model]) {\n    channels = convert[this.model].channels;\n\n    for (i = 0; i < channels; i++) {\n      const limit = limiters[this.model][i];\n\n      if (limit) {\n        this.color[i] = limit(this.color[i]);\n      }\n    }\n  }\n\n  this.valpha = Math.max(0, Math.min(1, this.valpha));\n\n  if (Object.freeze) {\n    Object.freeze(this);\n  }\n}\n\nColor.prototype = {\n  toString() {\n    return this.string();\n  },\n\n  toJSON() {\n    return this[this.model]();\n  },\n\n  string(places) {\n    let self = this.model in colorString.to ? this : this.rgb();\n    self = self.round(typeof places === 'number' ? places : 1);\n    const args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n    return colorString.to[self.model](args);\n  },\n\n  percentString(places) {\n    const self = this.rgb().round(typeof places === 'number' ? places : 1);\n    const args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n    return colorString.to.rgb.percent(args);\n  },\n\n  array() {\n    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);\n  },\n\n  object() {\n    const result = {};\n    const channels = convert[this.model].channels;\n    const labels = convert[this.model].labels;\n\n    for (let i = 0; i < channels; i++) {\n      result[labels[i]] = this.color[i];\n    }\n\n    if (this.valpha !== 1) {\n      result.alpha = this.valpha;\n    }\n\n    return result;\n  },\n\n  unitArray() {\n    const rgb = this.rgb().color;\n    rgb[0] /= 255;\n    rgb[1] /= 255;\n    rgb[2] /= 255;\n\n    if (this.valpha !== 1) {\n      rgb.push(this.valpha);\n    }\n\n    return rgb;\n  },\n\n  unitObject() {\n    const rgb = this.rgb().object();\n    rgb.r /= 255;\n    rgb.g /= 255;\n    rgb.b /= 255;\n\n    if (this.valpha !== 1) {\n      rgb.alpha = this.valpha;\n    }\n\n    return rgb;\n  },\n\n  round(places) {\n    places = Math.max(places || 0, 0);\n    return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);\n  },\n\n  alpha(value) {\n    if (arguments.length > 0) {\n      return new Color(this.color.concat(Math.max(0, Math.min(1, value))), this.model);\n    }\n\n    return this.valpha;\n  },\n\n  // Rgb\n  red: getset('rgb', 0, maxfn(255)),\n  green: getset('rgb', 1, maxfn(255)),\n  blue: getset('rgb', 2, maxfn(255)),\n  hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => (value % 360 + 360) % 360),\n  saturationl: getset('hsl', 1, maxfn(100)),\n  lightness: getset('hsl', 2, maxfn(100)),\n  saturationv: getset('hsv', 1, maxfn(100)),\n  value: getset('hsv', 2, maxfn(100)),\n  chroma: getset('hcg', 1, maxfn(100)),\n  gray: getset('hcg', 2, maxfn(100)),\n  white: getset('hwb', 1, maxfn(100)),\n  wblack: getset('hwb', 2, maxfn(100)),\n  cyan: getset('cmyk', 0, maxfn(100)),\n  magenta: getset('cmyk', 1, maxfn(100)),\n  yellow: getset('cmyk', 2, maxfn(100)),\n  black: getset('cmyk', 3, maxfn(100)),\n  x: getset('xyz', 0, maxfn(100)),\n  y: getset('xyz', 1, maxfn(100)),\n  z: getset('xyz', 2, maxfn(100)),\n  l: getset('lab', 0, maxfn(100)),\n  a: getset('lab', 1),\n  b: getset('lab', 2),\n\n  keyword(value) {\n    if (arguments.length > 0) {\n      return new Color(value);\n    }\n\n    return convert[this.model].keyword(this.color);\n  },\n\n  hex(value) {\n    if (arguments.length > 0) {\n      return new Color(value);\n    }\n\n    return colorString.to.hex(this.rgb().round().color);\n  },\n\n  hexa(value) {\n    if (arguments.length > 0) {\n      return new Color(value);\n    }\n\n    const rgbArray = this.rgb().round().color;\n    let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n\n    if (alphaHex.length === 1) {\n      alphaHex = '0' + alphaHex;\n    }\n\n    return colorString.to.hex(rgbArray) + alphaHex;\n  },\n\n  rgbNumber() {\n    const rgb = this.rgb().color;\n    return (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | rgb[2] & 0xFF;\n  },\n\n  luminosity() {\n    // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n    const rgb = this.rgb().color;\n    const lum = [];\n\n    for (const [i, element] of rgb.entries()) {\n      const chan = element / 255;\n      lum[i] = chan <= 0.039_28 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n    }\n\n    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n  },\n\n  contrast(color2) {\n    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n    const lum1 = this.luminosity();\n    const lum2 = color2.luminosity();\n\n    if (lum1 > lum2) {\n      return (lum1 + 0.05) / (lum2 + 0.05);\n    }\n\n    return (lum2 + 0.05) / (lum1 + 0.05);\n  },\n\n  level(color2) {\n    const contrastRatio = this.contrast(color2);\n\n    if (contrastRatio >= 7.1) {\n      return 'AAA';\n    }\n\n    return contrastRatio >= 4.5 ? 'AA' : '';\n  },\n\n  isDark() {\n    // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n    const rgb = this.rgb().color;\n    const yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n    return yiq < 128;\n  },\n\n  isLight() {\n    return !this.isDark();\n  },\n\n  negate() {\n    const rgb = this.rgb();\n\n    for (let i = 0; i < 3; i++) {\n      rgb.color[i] = 255 - rgb.color[i];\n    }\n\n    return rgb;\n  },\n\n  lighten(ratio) {\n    const hsl = this.hsl();\n    hsl.color[2] += hsl.color[2] * ratio;\n    return hsl;\n  },\n\n  darken(ratio) {\n    const hsl = this.hsl();\n    hsl.color[2] -= hsl.color[2] * ratio;\n    return hsl;\n  },\n\n  saturate(ratio) {\n    const hsl = this.hsl();\n    hsl.color[1] += hsl.color[1] * ratio;\n    return hsl;\n  },\n\n  desaturate(ratio) {\n    const hsl = this.hsl();\n    hsl.color[1] -= hsl.color[1] * ratio;\n    return hsl;\n  },\n\n  whiten(ratio) {\n    const hwb = this.hwb();\n    hwb.color[1] += hwb.color[1] * ratio;\n    return hwb;\n  },\n\n  blacken(ratio) {\n    const hwb = this.hwb();\n    hwb.color[2] += hwb.color[2] * ratio;\n    return hwb;\n  },\n\n  grayscale() {\n    // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n    const rgb = this.rgb().color;\n    const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n    return Color.rgb(value, value, value);\n  },\n\n  fade(ratio) {\n    return this.alpha(this.valpha - this.valpha * ratio);\n  },\n\n  opaquer(ratio) {\n    return this.alpha(this.valpha + this.valpha * ratio);\n  },\n\n  rotate(degrees) {\n    const hsl = this.hsl();\n    let hue = hsl.color[0];\n    hue = (hue + degrees) % 360;\n    hue = hue < 0 ? 360 + hue : hue;\n    hsl.color[0] = hue;\n    return hsl;\n  },\n\n  mix(mixinColor, weight) {\n    // Ported from sass implementation in C\n    // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n    if (!mixinColor || !mixinColor.rgb) {\n      throw new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n    }\n\n    const color1 = mixinColor.rgb();\n    const color2 = this.rgb();\n    const p = weight === undefined ? 0.5 : weight;\n    const w = 2 * p - 1;\n    const a = color1.alpha() - color2.alpha();\n    const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;\n    const w2 = 1 - w1;\n    return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));\n  }\n\n}; // Model conversion methods and static constructors\n\nfor (const model of Object.keys(convert)) {\n  if (skippedModels.includes(model)) {\n    continue;\n  }\n\n  const channels = convert[model].channels; // Conversion methods\n\n  Color.prototype[model] = function () {\n    if (this.model === model) {\n      return new Color(this);\n    }\n\n    if (arguments.length > 0) {\n      return new Color(arguments, model);\n    }\n\n    const newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;\n    return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);\n  }; // 'static' construction methods\n\n\n  Color[model] = function (color) {\n    if (typeof color === 'number') {\n      color = zeroArray(_slice.call(arguments), channels);\n    }\n\n    return new Color(color, model);\n  };\n}\n\nfunction roundTo(number, places) {\n  return Number(number.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n  return function (number) {\n    return roundTo(number, places);\n  };\n}\n\nfunction getset(model, channel, modifier) {\n  model = Array.isArray(model) ? model : [model];\n\n  for (const m of model) {\n    (limiters[m] || (limiters[m] = []))[channel] = modifier;\n  }\n\n  model = model[0];\n  return function (value) {\n    let result;\n\n    if (arguments.length > 0) {\n      if (modifier) {\n        value = modifier(value);\n      }\n\n      result = this[model]();\n      result.color[channel] = value;\n      return result;\n    }\n\n    result = this[model]().color[channel];\n\n    if (modifier) {\n      result = modifier(result);\n    }\n\n    return result;\n  };\n}\n\nfunction maxfn(max) {\n  return function (v) {\n    return Math.max(0, Math.min(max, v));\n  };\n}\n\nfunction assertArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction zeroArray(array, length) {\n  for (let i = 0; i < length; i++) {\n    if (typeof array[i] !== 'number') {\n      array[i] = 0;\n    }\n  }\n\n  return array;\n}\n\nmodule.exports = Color;","map":{"version":3,"sources":["/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/node_modules/color/index.js"],"names":["colorString","require","convert","_slice","slice","skippedModels","hashedModelKeys","model","Object","keys","call","labels","sort","join","limiters","Color","object","Error","i","channels","color","valpha","result","get","value","length","newArray","zeroArray","splice","indexOf","alpha","hashedKeys","JSON","stringify","push","limit","Math","max","min","freeze","prototype","toString","string","toJSON","places","self","to","rgb","round","args","concat","percentString","percent","array","unitArray","unitObject","r","g","b","map","roundToPlace","arguments","red","getset","maxfn","green","blue","hue","saturationl","lightness","saturationv","chroma","gray","white","wblack","cyan","magenta","yellow","black","x","y","z","l","a","keyword","hex","hexa","rgbArray","alphaHex","toUpperCase","rgbNumber","luminosity","lum","element","entries","chan","contrast","color2","lum1","lum2","level","contrastRatio","isDark","yiq","isLight","negate","lighten","ratio","hsl","darken","saturate","desaturate","whiten","hwb","blacken","grayscale","fade","opaquer","rotate","degrees","mix","mixinColor","weight","color1","p","undefined","w","w1","w2","includes","newAlpha","assertArray","raw","roundTo","number","Number","toFixed","channel","modifier","Array","isArray","m","v","module","exports"],"mappings":"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","sourcesContent":["const colorString = require('color-string');\nconst convert = require('color-convert');\n\nconst _slice = [].slice;\n\nconst skippedModels = [\n\t// To be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// Gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// Shouldn't really be in color-convert either...\n\t'hex',\n];\n\nconst hashedModelKeys = {};\nfor (const model of Object.keys(convert)) {\n\thashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;\n}\n\nconst limiters = {};\n\nfunction Color(object, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(object, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tlet i;\n\tlet channels;\n\n\tif (object == null) { // eslint-disable-line no-eq-null,eqeqeq\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (object instanceof Color) {\n\t\tthis.model = object.model;\n\t\tthis.color = object.color.slice();\n\t\tthis.valpha = object.valpha;\n\t} else if (typeof object === 'string') {\n\t\tconst result = colorString.get(object);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + object);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (object.length > 0) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tconst newArray = _slice.call(object, 0, channels);\n\t\tthis.color = zeroArray(newArray, channels);\n\t\tthis.valpha = typeof object[channels] === 'number' ? object[channels] : 1;\n\t} else if (typeof object === 'number') {\n\t\t// This is always RGB - can be converted later on.\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(object >> 16) & 0xFF,\n\t\t\t(object >> 8) & 0xFF,\n\t\t\tobject & 0xFF,\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tconst keys = Object.keys(object);\n\t\tif ('alpha' in object) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof object.alpha === 'number' ? object.alpha : 0;\n\t\t}\n\n\t\tconst hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(object));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tconst labels = convert[this.model].labels;\n\t\tconst color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(object[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// Perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tconst limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString() {\n\t\treturn this.string();\n\t},\n\n\ttoJSON() {\n\t\treturn this[this.model]();\n\t},\n\n\tstring(places) {\n\t\tlet self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString(places) {\n\t\tconst self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tconst args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray() {\n\t\treturn this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);\n\t},\n\n\tobject() {\n\t\tconst result = {};\n\t\tconst channels = convert[this.model].channels;\n\t\tconst labels = convert[this.model].labels;\n\n\t\tfor (let i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray() {\n\t\tconst rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject() {\n\t\tconst rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround(places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);\n\t},\n\n\talpha(value) {\n\t\tif (arguments.length > 0) {\n\t\t\treturn new Color(this.color.concat(Math.max(0, Math.min(1, value))), this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// Rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(100)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(100)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword(value) {\n\t\tif (arguments.length > 0) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex(value) {\n\t\tif (arguments.length > 0) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\thexa(value) {\n\t\tif (arguments.length > 0) {\n\t\t\treturn new Color(value);\n\t\t}\n\n\t\tconst rgbArray = this.rgb().round().color;\n\n\t\tlet alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n\t\tif (alphaHex.length === 1) {\n\t\t\talphaHex = '0' + alphaHex;\n\t\t}\n\n\t\treturn colorString.to.hex(rgbArray) + alphaHex;\n\t},\n\n\trgbNumber() {\n\t\tconst rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity() {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tconst rgb = this.rgb().color;\n\n\t\tconst lum = [];\n\t\tfor (const [i, element] of rgb.entries()) {\n\t\t\tconst chan = element / 255;\n\t\t\tlum[i] = (chan <= 0.039_28) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast(color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tconst lum1 = this.luminosity();\n\t\tconst lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel(color2) {\n\t\tconst contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tisDark() {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tconst rgb = this.rgb().color;\n\t\tconst yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tisLight() {\n\t\treturn !this.isDark();\n\t},\n\n\tnegate() {\n\t\tconst rgb = this.rgb();\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tlighten(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate(ratio) {\n\t\tconst hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken(ratio) {\n\t\tconst hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale() {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tconst rgb = this.rgb().color;\n\t\tconst value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(value, value, value);\n\t},\n\n\tfade(ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer(ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate(degrees) {\n\t\tconst hsl = this.hsl();\n\t\tlet hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix(mixinColor, weight) {\n\t\t// Ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tif (!mixinColor || !mixinColor.rgb) {\n\t\t\tthrow new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n\t\t}\n\n\t\tconst color1 = mixinColor.rgb();\n\t\tconst color2 = this.rgb();\n\t\tconst p = weight === undefined ? 0.5 : weight;\n\n\t\tconst w = 2 * p - 1;\n\t\tconst a = color1.alpha() - color2.alpha();\n\n\t\tconst w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;\n\t\tconst w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n};\n\n// Model conversion methods and static constructors\nfor (const model of Object.keys(convert)) {\n\tif (skippedModels.includes(model)) {\n\t\tcontinue;\n\t}\n\n\tconst channels = convert[model].channels;\n\n\t// Conversion methods\n\tColor.prototype[model] = function () {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\treturn new Color(arguments, model);\n\t\t}\n\n\t\tconst newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;\n\t\treturn new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (color) {\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(_slice.call(arguments), channels);\n\t\t}\n\n\t\treturn new Color(color, model);\n\t};\n}\n\nfunction roundTo(number, places) {\n\treturn Number(number.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (number) {\n\t\treturn roundTo(number, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tfor (const m of model) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t}\n\n\tmodel = model[0];\n\n\treturn function (value) {\n\t\tlet result;\n\n\t\tif (arguments.length > 0) {\n\t\t\tif (modifier) {\n\t\t\t\tvalue = modifier(value);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = value;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(value) {\n\treturn Array.isArray(value) ? value : [value];\n}\n\nfunction zeroArray(array, length) {\n\tfor (let i = 0; i < length; i++) {\n\t\tif (typeof array[i] !== 'number') {\n\t\t\tarray[i] = 0;\n\t\t}\n\t}\n\n\treturn array;\n}\n\nmodule.exports = Color;\n"]},"metadata":{},"sourceType":"script"}