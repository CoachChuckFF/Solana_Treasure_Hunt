{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst is = require('./is');\n\nrequire('./libvips').hasVendoredLibvips();\n\nrequire('./sharp'); // Use NODE_DEBUG=sharp to enable libvips warnings\n\n\nconst debuglog = util.debuglog('sharp');\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }).toFile('noise.png');\n *\n * @param {(Buffer|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|string)} [input] - if present, can be\n *  a Buffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image data, or\n *  a TypedArray containing raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {boolean} [options.failOnError=true] - by default halt processing and raise an error when loading invalid images.\n *  Set this flag to `false` if you'd rather apply a \"best effort\" to decode images, even if the data is corrupt or invalid.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.sequentialRead=false] - Set this to `true` to use sequential rather than random access where possible.\n *  This can reduce memory usage and might improve performance on some systems.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.pages=1] - number of pages to extract for multi-page input (GIF, WebP, AVIF, TIFF, PDF), use -1 for all pages.\n * @param {number} [options.page=0] - page number to start extracting from for multi-page input (GIF, WebP, AVIF, TIFF, PDF), zero based.\n * @param {number} [options.subifd=-1] - subIFD (Sub Image File Directory) to extract for OME-TIFF, defaults to main image.\n * @param {number} [options.level=0] - level to extract from a multi-level input (OpenSlide), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (equivalent of setting `pages` to `-1`).\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {boolean} [options.raw.premultiplied] - specifies that the raw input has already been premultiplied, set to `true`\n *  to avoid sharp premultiplying the image. (optional, default `false`)\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean] - mean of pixels in generated noise.\n * @param {number} [options.create.noise.sigma] - standard deviation of pixels in generated noise.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    useExifOrientation: false,\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    withoutEnlargement: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tintA: 128,\n    tintB: 128,\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    negate: false,\n    negateAlpha: true,\n    medianSize: 0,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenFlat: 1,\n    sharpenJagged: 2,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimThreshold: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    claheWidth: 0,\n    claheHeight: 0,\n    claheMaxSlope: 3,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    lightness: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: -1,\n    colourspace: 'srgb',\n    colourspaceInput: 'last',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    withMetadataDensity: 0,\n    withMetadataIcc: '',\n    withMetadataStrs: {},\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 6,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngBitdepth: 8,\n    pngDither: 1,\n    jp2Quality: 80,\n    jp2TileHeight: 512,\n    jp2TileWidth: 512,\n    jp2Lossless: false,\n    jp2ChromaSubsampling: '4:4:4',\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpReductionEffort: 4,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifSpeed: 5,\n    heifChromaSubsampling: '4:4:4',\n    rawDepth: 'uchar',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    tileId: 'https://example.com/iiif',\n    timeoutSeconds: 0,\n    linearA: 1,\n    linearB: 0,\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, {\n    allowStream: true\n  });\n  return this;\n};\n\nObject.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);\nObject.setPrototypeOf(Sharp, stream.Duplex);\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({\n *   failOnError: false\n * });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got#gotstreamurl-options\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\n\nfunction clone() {\n  // Clone existing options\n  const clone = this.constructor.call();\n  clone.options = Object.assign({}, this.options); // Pass 'finish' event to clone for Stream-based input\n\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n\n      clone.options.bufferIn = this.options.bufferIn;\n      clone.emit('finish');\n    });\n  }\n\n  return clone;\n}\n\nObject.assign(Sharp.prototype, {\n  clone\n});\n/**\n * Export constructor.\n * @private\n */\n\nmodule.exports = Sharp;","map":{"version":3,"sources":["/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/node_modules/sharp/lib/constructor.js"],"names":["util","require","stream","is","hasVendoredLibvips","debuglog","Sharp","input","options","arguments","length","defined","Error","Duplex","call","topOffsetPre","leftOffsetPre","widthPre","heightPre","topOffsetPost","leftOffsetPost","widthPost","heightPost","width","height","canvas","position","resizeBackground","useExifOrientation","angle","rotationAngle","rotationBackground","rotateBeforePreExtract","flip","flop","extendTop","extendBottom","extendLeft","extendRight","extendBackground","withoutEnlargement","affineMatrix","affineBackground","affineIdx","affineIdy","affineOdx","affineOdy","affineInterpolator","constructor","interpolators","bilinear","kernel","fastShrinkOnLoad","tintA","tintB","flatten","flattenBackground","negate","negateAlpha","medianSize","blurSigma","sharpenSigma","sharpenFlat","sharpenJagged","threshold","thresholdGrayscale","trimThreshold","gamma","gammaOut","greyscale","normalise","claheWidth","claheHeight","claheMaxSlope","brightness","saturation","hue","lightness","booleanBufferIn","booleanFileIn","joinChannelIn","extractChannel","removeAlpha","ensureAlpha","colourspace","colourspaceInput","composite","fileOut","formatOut","streamOut","withMetadata","withMetadataOrientation","withMetadataDensity","withMetadataIcc","withMetadataStrs","resolveWithObject","jpegQuality","jpegProgressive","jpegChromaSubsampling","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegOptimiseCoding","jpegQuantisationTable","pngProgressive","pngCompressionLevel","pngAdaptiveFiltering","pngPalette","pngQuality","pngBitdepth","pngDither","jp2Quality","jp2TileHeight","jp2TileWidth","jp2Lossless","jp2ChromaSubsampling","webpQuality","webpAlphaQuality","webpLossless","webpNearLossless","webpSmartSubsample","webpReductionEffort","tiffQuality","tiffCompression","tiffPredictor","tiffPyramid","tiffBitdepth","tiffTile","tiffTileHeight","tiffTileWidth","tiffXres","tiffYres","heifQuality","heifLossless","heifCompression","heifSpeed","heifChromaSubsampling","rawDepth","tileSize","tileOverlap","tileContainer","tileLayout","tileFormat","tileDepth","tileAngle","tileSkipBlanks","tileBackground","tileCentre","tileId","timeoutSeconds","linearA","linearB","warning","emit","queueListener","queueLength","queue","_createInputDescriptor","allowStream","Object","setPrototypeOf","prototype","clone","assign","_isStreamInput","on","_flattenBufferIn","bufferIn","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AAEAA,OAAO,CAAC,WAAD,CAAP,CAAqBG,kBAArB;;AACAH,OAAO,CAAC,SAAD,CAAP,C,CAEA;;;AACA,MAAMI,QAAQ,GAAGL,IAAI,CAACK,QAAL,CAAc,OAAd,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,KAAK,GAAG,UAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AACtC,MAAIC,SAAS,CAACC,MAAV,KAAqB,CAArB,IAA0B,CAACP,EAAE,CAACQ,OAAH,CAAWJ,KAAX,CAA/B,EAAkD;AAChD,UAAM,IAAIK,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,MAAI,EAAE,gBAAgBN,KAAlB,CAAJ,EAA8B;AAC5B,WAAO,IAAIA,KAAJ,CAAUC,KAAV,EAAiBC,OAAjB,CAAP;AACD;;AACDN,EAAAA,MAAM,CAACW,MAAP,CAAcC,IAAd,CAAmB,IAAnB;AAC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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst stream = require('stream');\nconst is = require('./is');\n\nrequire('./libvips').hasVendoredLibvips();\nrequire('./sharp');\n\n// Use NODE_DEBUG=sharp to enable libvips warnings\nconst debuglog = util.debuglog('sharp');\n\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }).toFile('noise.png');\n *\n * @param {(Buffer|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|string)} [input] - if present, can be\n *  a Buffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image data, or\n *  a TypedArray containing raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {boolean} [options.failOnError=true] - by default halt processing and raise an error when loading invalid images.\n *  Set this flag to `false` if you'd rather apply a \"best effort\" to decode images, even if the data is corrupt or invalid.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.sequentialRead=false] - Set this to `true` to use sequential rather than random access where possible.\n *  This can reduce memory usage and might improve performance on some systems.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.pages=1] - number of pages to extract for multi-page input (GIF, WebP, AVIF, TIFF, PDF), use -1 for all pages.\n * @param {number} [options.page=0] - page number to start extracting from for multi-page input (GIF, WebP, AVIF, TIFF, PDF), zero based.\n * @param {number} [options.subifd=-1] - subIFD (Sub Image File Directory) to extract for OME-TIFF, defaults to main image.\n * @param {number} [options.level=0] - level to extract from a multi-level input (OpenSlide), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (equivalent of setting `pages` to `-1`).\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {boolean} [options.raw.premultiplied] - specifies that the raw input has already been premultiplied, set to `true`\n *  to avoid sharp premultiplying the image. (optional, default `false`)\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean] - mean of pixels in generated noise.\n * @param {number} [options.create.noise.sigma] - standard deviation of pixels in generated noise.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    useExifOrientation: false,\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    withoutEnlargement: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tintA: 128,\n    tintB: 128,\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    negate: false,\n    negateAlpha: true,\n    medianSize: 0,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenFlat: 1,\n    sharpenJagged: 2,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimThreshold: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    claheWidth: 0,\n    claheHeight: 0,\n    claheMaxSlope: 3,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    lightness: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: -1,\n    colourspace: 'srgb',\n    colourspaceInput: 'last',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    withMetadataDensity: 0,\n    withMetadataIcc: '',\n    withMetadataStrs: {},\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 6,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngBitdepth: 8,\n    pngDither: 1,\n    jp2Quality: 80,\n    jp2TileHeight: 512,\n    jp2TileWidth: 512,\n    jp2Lossless: false,\n    jp2ChromaSubsampling: '4:4:4',\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpReductionEffort: 4,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifSpeed: 5,\n    heifChromaSubsampling: '4:4:4',\n    rawDepth: 'uchar',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    tileId: 'https://example.com/iiif',\n    timeoutSeconds: 0,\n    linearA: 1,\n    linearB: 0,\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, { allowStream: true });\n  return this;\n};\nObject.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);\nObject.setPrototypeOf(Sharp, stream.Duplex);\n\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({\n *   failOnError: false\n * });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got#gotstreamurl-options\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\nfunction clone () {\n  // Clone existing options\n  const clone = this.constructor.call();\n  clone.options = Object.assign({}, this.options);\n  // Pass 'finish' event to clone for Stream-based input\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n      clone.options.bufferIn = this.options.bufferIn;\n      clone.emit('finish');\n    });\n  }\n  return clone;\n}\nObject.assign(Sharp.prototype, { clone });\n\n/**\n * Export constructor.\n * @private\n */\nmodule.exports = Sharp;\n"]},"metadata":{},"sourceType":"script"}