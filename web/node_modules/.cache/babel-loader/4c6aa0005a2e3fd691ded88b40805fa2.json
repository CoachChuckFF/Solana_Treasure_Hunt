{"ast":null,"code":"'use strict';\n\nconst is = require('./is');\n/**\n * Weighting to apply when using contain/cover fit.\n * @member\n * @private\n */\n\n\nconst gravity = {\n  center: 0,\n  centre: 0,\n  north: 1,\n  east: 2,\n  south: 3,\n  west: 4,\n  northeast: 5,\n  southeast: 6,\n  southwest: 7,\n  northwest: 8\n};\n/**\n * Position to apply when using contain/cover fit.\n * @member\n * @private\n */\n\nconst position = {\n  top: 1,\n  right: 2,\n  bottom: 3,\n  left: 4,\n  'right top': 5,\n  'right bottom': 6,\n  'left bottom': 7,\n  'left top': 8\n};\n/**\n * Strategies for automagic cover behaviour.\n * @member\n * @private\n */\n\nconst strategy = {\n  entropy: 16,\n  attention: 17\n};\n/**\n * Reduction kernels.\n * @member\n * @private\n */\n\nconst kernel = {\n  nearest: 'nearest',\n  cubic: 'cubic',\n  mitchell: 'mitchell',\n  lanczos2: 'lanczos2',\n  lanczos3: 'lanczos3'\n};\n/**\n * Methods by which an image can be resized to fit the provided dimensions.\n * @member\n * @private\n */\n\nconst fit = {\n  contain: 'contain',\n  cover: 'cover',\n  fill: 'fill',\n  inside: 'inside',\n  outside: 'outside'\n};\n/**\n * Map external fit property to internal canvas property.\n * @member\n * @private\n */\n\nconst mapFitToCanvas = {\n  contain: 'embed',\n  cover: 'crop',\n  fill: 'ignore_aspect',\n  inside: 'max',\n  outside: 'min'\n};\n/**\n * @private\n */\n\nfunction isRotationExpected(options) {\n  return options.angle % 360 !== 0 || options.useExifOrientation === true || options.rotationAngle !== 0;\n}\n/**\n * Resize image to `width`, `height` or `width x height`.\n *\n * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:\n * - `cover`: (default) Preserving aspect ratio, ensure the image covers both provided dimensions by cropping/clipping to fit.\n * - `contain`: Preserving aspect ratio, contain within both provided dimensions using \"letterboxing\" where necessary.\n * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.\n * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.\n * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.\n *\n * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.\n *\n * When using a `fit` of `cover` or `contain`, the default **position** is `centre`. Other options are:\n * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.\n * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.\n * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.\n *\n * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.\n *\n * The experimental strategy-based approach resizes so one dimension is at its target length\n * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.\n * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).\n * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.\n *\n * Possible interpolation kernels are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).\n * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).\n * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.\n * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).\n *\n * @example\n * sharp(input)\n *   .resize({ width: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels wide, auto-scaled height\n *   });\n *\n * @example\n * sharp(input)\n *   .resize({ height: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels high, auto-scaled width\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 300, {\n *     kernel: sharp.kernel.nearest,\n *     fit: 'contain',\n *     position: 'right top',\n *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }\n *   })\n *   .toFile('output.png')\n *   .then(() => {\n *     // output.png is a 200 pixels wide and 300 pixels high image\n *     // containing a nearest-neighbour scaled version\n *     // contained within the north-east corner of a semi-transparent white canvas\n *   });\n *\n * @example\n * const transformer = sharp()\n *   .resize({\n *     width: 200,\n *     height: 200,\n *     fit: sharp.fit.cover,\n *     position: sharp.strategy.entropy\n *   });\n * // Read image data from readableStream\n * // Write 200px square auto-cropped image data to writableStream\n * readableStream\n *   .pipe(transformer)\n *   .pipe(writableStream);\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.inside,\n *     withoutEnlargement: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // no wider and no higher than 200 pixels\n *     // and no larger than the input image\n *   });\n *\n * @example\n * const scaleByHalf = await sharp(input)\n *   .metadata()\n *   .then(({ width }) => sharp(input)\n *     .resize(Math.round(width * 0.5))\n *     .toBuffer()\n *   );\n *\n * @param {number} [width] - pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.\n * @param {number} [height] - pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.\n * @param {Object} [options]\n * @param {String} [options.width] - alternative means of specifying `width`. If both are present this take priority.\n * @param {String} [options.height] - alternative means of specifying `height`. If both are present this take priority.\n * @param {String} [options.fit='cover'] - how the image should be resized to fit both provided dimensions, one of `cover`, `contain`, `fill`, `inside` or `outside`.\n * @param {String} [options.position='centre'] - position, gravity or strategy to use when `fit` is `cover` or `contain`.\n * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when using a `fit` of `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @param {String} [options.kernel='lanczos3'] - the kernel to use for image reduction.\n * @param {Boolean} [options.withoutEnlargement=false] - do not enlarge if the width *or* height are already less than the specified dimensions, equivalent to GraphicsMagick's `>` geometry option.\n * @param {Boolean} [options.fastShrinkOnLoad=true] - take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moirÃ© pattern on some images.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction resize(width, height, options) {\n  if (is.defined(width)) {\n    if (is.object(width) && !is.defined(options)) {\n      options = width;\n    } else if (is.integer(width) && width > 0) {\n      this.options.width = width;\n    } else {\n      throw is.invalidParameterError('width', 'positive integer', width);\n    }\n  } else {\n    this.options.width = -1;\n  }\n\n  if (is.defined(height)) {\n    if (is.integer(height) && height > 0) {\n      this.options.height = height;\n    } else {\n      throw is.invalidParameterError('height', 'positive integer', height);\n    }\n  } else {\n    this.options.height = -1;\n  }\n\n  if (is.object(options)) {\n    // Width\n    if (is.defined(options.width)) {\n      if (is.integer(options.width) && options.width > 0) {\n        this.options.width = options.width;\n      } else {\n        throw is.invalidParameterError('width', 'positive integer', options.width);\n      }\n    } // Height\n\n\n    if (is.defined(options.height)) {\n      if (is.integer(options.height) && options.height > 0) {\n        this.options.height = options.height;\n      } else {\n        throw is.invalidParameterError('height', 'positive integer', options.height);\n      }\n    } // Fit\n\n\n    if (is.defined(options.fit)) {\n      const canvas = mapFitToCanvas[options.fit];\n\n      if (is.string(canvas)) {\n        this.options.canvas = canvas;\n      } else {\n        throw is.invalidParameterError('fit', 'valid fit', options.fit);\n      }\n    } // Position\n\n\n    if (is.defined(options.position)) {\n      const pos = is.integer(options.position) ? options.position : strategy[options.position] || position[options.position] || gravity[options.position];\n\n      if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {\n        this.options.position = pos;\n      } else {\n        throw is.invalidParameterError('position', 'valid position/gravity/strategy', options.position);\n      }\n    } // Background\n\n\n    this._setBackgroundColourOption('resizeBackground', options.background); // Kernel\n\n\n    if (is.defined(options.kernel)) {\n      if (is.string(kernel[options.kernel])) {\n        this.options.kernel = kernel[options.kernel];\n      } else {\n        throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);\n      }\n    } // Without enlargement\n\n\n    if (is.defined(options.withoutEnlargement)) {\n      this._setBooleanOption('withoutEnlargement', options.withoutEnlargement);\n    } // Shrink on load\n\n\n    if (is.defined(options.fastShrinkOnLoad)) {\n      this._setBooleanOption('fastShrinkOnLoad', options.fastShrinkOnLoad);\n    }\n  }\n\n  return this;\n}\n/**\n * Extends/pads the edges of the image with the provided background colour.\n * This operation will always occur after resizing and extraction, if any.\n *\n * @example\n * // Resize to 140 pixels wide, then add 10 transparent pixels\n * // to the top, left and right edges and 20 to the bottom edge\n * sharp(input)\n *   .resize(140)\n *   .extend({\n *     top: 10,\n *     bottom: 20,\n *     left: 10,\n *     right: 10,\n *     background: { r: 0, g: 0, b: 0, alpha: 0 }\n *   })\n *   ...\n *\n* @example\n * // Add a row of 10 red pixels to the bottom\n * sharp(input)\n *   .extend({\n *     bottom: 10,\n *     background: 'red'\n *   })\n *   ...\n *\n * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts\n * @param {number} [extend.top=0]\n * @param {number} [extend.left=0]\n * @param {number} [extend.bottom=0]\n * @param {number} [extend.right=0]\n * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n*/\n\n\nfunction extend(extend) {\n  if (is.integer(extend) && extend > 0) {\n    this.options.extendTop = extend;\n    this.options.extendBottom = extend;\n    this.options.extendLeft = extend;\n    this.options.extendRight = extend;\n  } else if (is.object(extend)) {\n    if (is.defined(extend.top)) {\n      if (is.integer(extend.top) && extend.top >= 0) {\n        this.options.extendTop = extend.top;\n      } else {\n        throw is.invalidParameterError('top', 'positive integer', extend.top);\n      }\n    }\n\n    if (is.defined(extend.bottom)) {\n      if (is.integer(extend.bottom) && extend.bottom >= 0) {\n        this.options.extendBottom = extend.bottom;\n      } else {\n        throw is.invalidParameterError('bottom', 'positive integer', extend.bottom);\n      }\n    }\n\n    if (is.defined(extend.left)) {\n      if (is.integer(extend.left) && extend.left >= 0) {\n        this.options.extendLeft = extend.left;\n      } else {\n        throw is.invalidParameterError('left', 'positive integer', extend.left);\n      }\n    }\n\n    if (is.defined(extend.right)) {\n      if (is.integer(extend.right) && extend.right >= 0) {\n        this.options.extendRight = extend.right;\n      } else {\n        throw is.invalidParameterError('right', 'positive integer', extend.right);\n      }\n    }\n\n    this._setBackgroundColourOption('extendBackground', extend.background);\n  } else {\n    throw is.invalidParameterError('extend', 'integer or object', extend);\n  }\n\n  return this;\n}\n/**\n * Extract/crop a region of the image.\n *\n * - Use `extract` before `resize` for pre-resize extraction.\n * - Use `extract` after `resize` for post-resize extraction.\n * - Use `extract` before and after for both.\n *\n * @example\n * sharp(input)\n *   .extract({ left: left, top: top, width: width, height: height })\n *   .toFile(output, function(err) {\n *     // Extract a region of the input image, saving in the same format.\n *   });\n * @example\n * sharp(input)\n *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })\n *   .resize(width, height)\n *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })\n *   .toFile(output, function(err) {\n *     // Extract a region, resize, then extract from the resized image\n *   });\n *\n * @param {Object} options - describes the region to extract using integral pixel values\n * @param {number} options.left - zero-indexed offset from left edge\n * @param {number} options.top - zero-indexed offset from top edge\n * @param {number} options.width - width of region to extract\n * @param {number} options.height - height of region to extract\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction extract(options) {\n  const suffix = this.options.width === -1 && this.options.height === -1 ? 'Pre' : 'Post';\n  ['left', 'top', 'width', 'height'].forEach(function (name) {\n    const value = options[name];\n\n    if (is.integer(value) && value >= 0) {\n      this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;\n    } else {\n      throw is.invalidParameterError(name, 'integer', value);\n    }\n  }, this); // Ensure existing rotation occurs before pre-resize extraction\n\n  if (suffix === 'Pre' && isRotationExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n\n  return this;\n}\n/**\n * Trim \"boring\" pixels from all edges that contain values similar to the top-left pixel.\n * Images consisting entirely of a single colour will calculate \"boring\" using the alpha channel, if any.\n *\n * The `info` response Object, obtained from callback of `.toFile()` or `.toBuffer()`,\n * will contain `trimOffsetLeft` and `trimOffsetTop` properties.\n *\n * @param {number} [threshold=10] the allowed difference from the top-left pixel, a number greater than zero.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction trim(threshold) {\n  if (!is.defined(threshold)) {\n    this.options.trimThreshold = 10;\n  } else if (is.number(threshold) && threshold > 0) {\n    this.options.trimThreshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'number greater than zero', threshold);\n  }\n\n  if (this.options.trimThreshold && isRotationExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n\n  return this;\n}\n/**\n * Decorate the Sharp prototype with resize-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    resize,\n    extend,\n    extract,\n    trim\n  }); // Class attributes\n\n  Sharp.gravity = gravity;\n  Sharp.strategy = strategy;\n  Sharp.kernel = kernel;\n  Sharp.fit = fit;\n  Sharp.position = position;\n};","map":{"version":3,"sources":["/Users/drkrueger/Work/foodfrenzy/solana/mekamounts/mekamountpfp/node_modules/sharp/lib/resize.js"],"names":["is","require","gravity","center","centre","north","east","south","west","northeast","southeast","southwest","northwest","position","top","right","bottom","left","strategy","entropy","attention","kernel","nearest","cubic","mitchell","lanczos2","lanczos3","fit","contain","cover","fill","inside","outside","mapFitToCanvas","isRotationExpected","options","angle","useExifOrientation","rotationAngle","resize","width","height","defined","object","integer","invalidParameterError","canvas","string","pos","inRange","_setBackgroundColourOption","background","withoutEnlargement","_setBooleanOption","fastShrinkOnLoad","extend","extendTop","extendBottom","extendLeft","extendRight","extract","suffix","forEach","name","value","rotateBeforePreExtract","trim","threshold","trimThreshold","number","module","exports","Sharp","Object","assign","prototype"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,OAAO,GAAG;AACdC,EAAAA,MAAM,EAAE,CADM;AAEdC,EAAAA,MAAM,EAAE,CAFM;AAGdC,EAAAA,KAAK,EAAE,CAHO;AAIdC,EAAAA,IAAI,EAAE,CAJQ;AAKdC,EAAAA,KAAK,EAAE,CALO;AAMdC,EAAAA,IAAI,EAAE,CANQ;AAOdC,EAAAA,SAAS,EAAE,CAPG;AAQdC,EAAAA,SAAS,EAAE,CARG;AASdC,EAAAA,SAAS,EAAE,CATG;AAUdC,EAAAA,SAAS,EAAE;AAVG,CAAhB;AAaA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAG;AACfC,EAAAA,GAAG,EAAE,CADU;AAEfC,EAAAA,KAAK,EAAE,CAFQ;AAGfC,EAAAA,MAAM,EAAE,CAHO;AAIfC,EAAAA,IAAI,EAAE,CAJS;AAKf,eAAa,CALE;AAMf,kBAAgB,CAND;AAOf,iBAAe,CAPA;AAQf,cAAY;AARG,CAAjB;AAWA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAG;AACfC,EAAAA,OAAO,EAAE,EADM;AAEfC,EAAAA,SAAS,EAAE;AAFI,CAAjB;AAKA;AACA;AACA;AACA;AACA;;AACA,MAAMC,MAAM,GAAG;AACbC,EAAAA,OAAO,EAAE,SADI;AAEbC,EAAAA,KAAK,EAAE,OAFM;AAGbC,EAAAA,QAAQ,EAAE,UAHG;AAIbC,EAAAA,QAAQ,EAAE,UAJG;AAKbC,EAAAA,QAAQ,EAAE;AALG,CAAf;AAQA;AACA;AACA;AACA;AACA;;AACA,MAAMC,GAAG,GAAG;AACVC,EAAAA,OAAO,EAAE,SADC;AAEVC,EAAAA,KAAK,EAAE,OAFG;AAGVC,EAAAA,IAAI,EAAE,MAHI;AAIVC,EAAAA,MAAM,EAAE,QAJE;AAKVC,EAAAA,OAAO,EAAE;AALC,CAAZ;AAQA;AACA;AACA;AACA;AACA;;AACA,MAAMC,cAAc,GAAG;AACrBL,EAAAA,OAAO,EAAE,OADY;AAErBC,EAAAA,KAAK,EAAE,MAFc;AAGrBC,EAAAA,IAAI,EAAE,eAHe;AAIrBC,EAAAA,MAAM,EAAE,KAJa;AAKrBC,EAAAA,OAAO,EAAE;AALY,CAAvB;AAQA;AACA;AACA;;AACA,SAASE,kBAAT,CAA6BC,OAA7B,EAAsC;AACpC,SAAQA,OAAO,CAACC,KAAR,GAAgB,GAAjB,KAA0B,CAA1B,IAA+BD,OAAO,CAACE,kBAAR,KAA+B,IAA9D,IAAsEF,OAAO,CAACG,aAAR,KAA0B,CAAvG;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,MAAT,CAAiBC,KAAjB,EAAwBC,MAAxB,EAAgCN,OAAhC,EAAyC;AACvC,MAAInC,EAAE,CAAC0C,OAAH,CAAWF,KAAX,CAAJ,EAAuB;AACrB,QAAIxC,EAAE,CAAC2C,MAAH,CAAUH,KAAV,KAAoB,CAACxC,EAAE,CAAC0C,OAAH,CAAWP,OAAX,CAAzB,EAA8C;AAC5CA,MAAAA,OAAO,GAAGK,KAAV;AACD,KAFD,MAEO,IAAIxC,EAAE,CAAC4C,OAAH,CAAWJ,KAAX,KAAqBA,KAAK,GAAG,CAAjC,EAAoC;AACzC,WAAKL,OAAL,CAAaK,KAAb,GAAqBA,KAArB;AACD,KAFM,MAEA;AACL,YAAMxC,EAAE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","sourcesContent":["'use strict';\n\nconst is = require('./is');\n\n/**\n * Weighting to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst gravity = {\n  center: 0,\n  centre: 0,\n  north: 1,\n  east: 2,\n  south: 3,\n  west: 4,\n  northeast: 5,\n  southeast: 6,\n  southwest: 7,\n  northwest: 8\n};\n\n/**\n * Position to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst position = {\n  top: 1,\n  right: 2,\n  bottom: 3,\n  left: 4,\n  'right top': 5,\n  'right bottom': 6,\n  'left bottom': 7,\n  'left top': 8\n};\n\n/**\n * Strategies for automagic cover behaviour.\n * @member\n * @private\n */\nconst strategy = {\n  entropy: 16,\n  attention: 17\n};\n\n/**\n * Reduction kernels.\n * @member\n * @private\n */\nconst kernel = {\n  nearest: 'nearest',\n  cubic: 'cubic',\n  mitchell: 'mitchell',\n  lanczos2: 'lanczos2',\n  lanczos3: 'lanczos3'\n};\n\n/**\n * Methods by which an image can be resized to fit the provided dimensions.\n * @member\n * @private\n */\nconst fit = {\n  contain: 'contain',\n  cover: 'cover',\n  fill: 'fill',\n  inside: 'inside',\n  outside: 'outside'\n};\n\n/**\n * Map external fit property to internal canvas property.\n * @member\n * @private\n */\nconst mapFitToCanvas = {\n  contain: 'embed',\n  cover: 'crop',\n  fill: 'ignore_aspect',\n  inside: 'max',\n  outside: 'min'\n};\n\n/**\n * @private\n */\nfunction isRotationExpected (options) {\n  return (options.angle % 360) !== 0 || options.useExifOrientation === true || options.rotationAngle !== 0;\n}\n\n/**\n * Resize image to `width`, `height` or `width x height`.\n *\n * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:\n * - `cover`: (default) Preserving aspect ratio, ensure the image covers both provided dimensions by cropping/clipping to fit.\n * - `contain`: Preserving aspect ratio, contain within both provided dimensions using \"letterboxing\" where necessary.\n * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.\n * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.\n * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.\n *\n * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.\n *\n * When using a `fit` of `cover` or `contain`, the default **position** is `centre`. Other options are:\n * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.\n * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.\n * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.\n *\n * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.\n *\n * The experimental strategy-based approach resizes so one dimension is at its target length\n * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.\n * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).\n * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.\n *\n * Possible interpolation kernels are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).\n * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).\n * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.\n * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).\n *\n * @example\n * sharp(input)\n *   .resize({ width: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels wide, auto-scaled height\n *   });\n *\n * @example\n * sharp(input)\n *   .resize({ height: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels high, auto-scaled width\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 300, {\n *     kernel: sharp.kernel.nearest,\n *     fit: 'contain',\n *     position: 'right top',\n *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }\n *   })\n *   .toFile('output.png')\n *   .then(() => {\n *     // output.png is a 200 pixels wide and 300 pixels high image\n *     // containing a nearest-neighbour scaled version\n *     // contained within the north-east corner of a semi-transparent white canvas\n *   });\n *\n * @example\n * const transformer = sharp()\n *   .resize({\n *     width: 200,\n *     height: 200,\n *     fit: sharp.fit.cover,\n *     position: sharp.strategy.entropy\n *   });\n * // Read image data from readableStream\n * // Write 200px square auto-cropped image data to writableStream\n * readableStream\n *   .pipe(transformer)\n *   .pipe(writableStream);\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.inside,\n *     withoutEnlargement: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // no wider and no higher than 200 pixels\n *     // and no larger than the input image\n *   });\n *\n * @example\n * const scaleByHalf = await sharp(input)\n *   .metadata()\n *   .then(({ width }) => sharp(input)\n *     .resize(Math.round(width * 0.5))\n *     .toBuffer()\n *   );\n *\n * @param {number} [width] - pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.\n * @param {number} [height] - pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.\n * @param {Object} [options]\n * @param {String} [options.width] - alternative means of specifying `width`. If both are present this take priority.\n * @param {String} [options.height] - alternative means of specifying `height`. If both are present this take priority.\n * @param {String} [options.fit='cover'] - how the image should be resized to fit both provided dimensions, one of `cover`, `contain`, `fill`, `inside` or `outside`.\n * @param {String} [options.position='centre'] - position, gravity or strategy to use when `fit` is `cover` or `contain`.\n * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when using a `fit` of `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @param {String} [options.kernel='lanczos3'] - the kernel to use for image reduction.\n * @param {Boolean} [options.withoutEnlargement=false] - do not enlarge if the width *or* height are already less than the specified dimensions, equivalent to GraphicsMagick's `>` geometry option.\n * @param {Boolean} [options.fastShrinkOnLoad=true] - take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moirÃ© pattern on some images.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction resize (width, height, options) {\n  if (is.defined(width)) {\n    if (is.object(width) && !is.defined(options)) {\n      options = width;\n    } else if (is.integer(width) && width > 0) {\n      this.options.width = width;\n    } else {\n      throw is.invalidParameterError('width', 'positive integer', width);\n    }\n  } else {\n    this.options.width = -1;\n  }\n  if (is.defined(height)) {\n    if (is.integer(height) && height > 0) {\n      this.options.height = height;\n    } else {\n      throw is.invalidParameterError('height', 'positive integer', height);\n    }\n  } else {\n    this.options.height = -1;\n  }\n  if (is.object(options)) {\n    // Width\n    if (is.defined(options.width)) {\n      if (is.integer(options.width) && options.width > 0) {\n        this.options.width = options.width;\n      } else {\n        throw is.invalidParameterError('width', 'positive integer', options.width);\n      }\n    }\n    // Height\n    if (is.defined(options.height)) {\n      if (is.integer(options.height) && options.height > 0) {\n        this.options.height = options.height;\n      } else {\n        throw is.invalidParameterError('height', 'positive integer', options.height);\n      }\n    }\n    // Fit\n    if (is.defined(options.fit)) {\n      const canvas = mapFitToCanvas[options.fit];\n      if (is.string(canvas)) {\n        this.options.canvas = canvas;\n      } else {\n        throw is.invalidParameterError('fit', 'valid fit', options.fit);\n      }\n    }\n    // Position\n    if (is.defined(options.position)) {\n      const pos = is.integer(options.position)\n        ? options.position\n        : strategy[options.position] || position[options.position] || gravity[options.position];\n      if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {\n        this.options.position = pos;\n      } else {\n        throw is.invalidParameterError('position', 'valid position/gravity/strategy', options.position);\n      }\n    }\n    // Background\n    this._setBackgroundColourOption('resizeBackground', options.background);\n    // Kernel\n    if (is.defined(options.kernel)) {\n      if (is.string(kernel[options.kernel])) {\n        this.options.kernel = kernel[options.kernel];\n      } else {\n        throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);\n      }\n    }\n    // Without enlargement\n    if (is.defined(options.withoutEnlargement)) {\n      this._setBooleanOption('withoutEnlargement', options.withoutEnlargement);\n    }\n    // Shrink on load\n    if (is.defined(options.fastShrinkOnLoad)) {\n      this._setBooleanOption('fastShrinkOnLoad', options.fastShrinkOnLoad);\n    }\n  }\n  return this;\n}\n\n/**\n * Extends/pads the edges of the image with the provided background colour.\n * This operation will always occur after resizing and extraction, if any.\n *\n * @example\n * // Resize to 140 pixels wide, then add 10 transparent pixels\n * // to the top, left and right edges and 20 to the bottom edge\n * sharp(input)\n *   .resize(140)\n *   .extend({\n *     top: 10,\n *     bottom: 20,\n *     left: 10,\n *     right: 10,\n *     background: { r: 0, g: 0, b: 0, alpha: 0 }\n *   })\n *   ...\n *\n* @example\n * // Add a row of 10 red pixels to the bottom\n * sharp(input)\n *   .extend({\n *     bottom: 10,\n *     background: 'red'\n *   })\n *   ...\n *\n * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts\n * @param {number} [extend.top=0]\n * @param {number} [extend.left=0]\n * @param {number} [extend.bottom=0]\n * @param {number} [extend.right=0]\n * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n*/\nfunction extend (extend) {\n  if (is.integer(extend) && extend > 0) {\n    this.options.extendTop = extend;\n    this.options.extendBottom = extend;\n    this.options.extendLeft = extend;\n    this.options.extendRight = extend;\n  } else if (is.object(extend)) {\n    if (is.defined(extend.top)) {\n      if (is.integer(extend.top) && extend.top >= 0) {\n        this.options.extendTop = extend.top;\n      } else {\n        throw is.invalidParameterError('top', 'positive integer', extend.top);\n      }\n    }\n    if (is.defined(extend.bottom)) {\n      if (is.integer(extend.bottom) && extend.bottom >= 0) {\n        this.options.extendBottom = extend.bottom;\n      } else {\n        throw is.invalidParameterError('bottom', 'positive integer', extend.bottom);\n      }\n    }\n    if (is.defined(extend.left)) {\n      if (is.integer(extend.left) && extend.left >= 0) {\n        this.options.extendLeft = extend.left;\n      } else {\n        throw is.invalidParameterError('left', 'positive integer', extend.left);\n      }\n    }\n    if (is.defined(extend.right)) {\n      if (is.integer(extend.right) && extend.right >= 0) {\n        this.options.extendRight = extend.right;\n      } else {\n        throw is.invalidParameterError('right', 'positive integer', extend.right);\n      }\n    }\n    this._setBackgroundColourOption('extendBackground', extend.background);\n  } else {\n    throw is.invalidParameterError('extend', 'integer or object', extend);\n  }\n  return this;\n}\n\n/**\n * Extract/crop a region of the image.\n *\n * - Use `extract` before `resize` for pre-resize extraction.\n * - Use `extract` after `resize` for post-resize extraction.\n * - Use `extract` before and after for both.\n *\n * @example\n * sharp(input)\n *   .extract({ left: left, top: top, width: width, height: height })\n *   .toFile(output, function(err) {\n *     // Extract a region of the input image, saving in the same format.\n *   });\n * @example\n * sharp(input)\n *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })\n *   .resize(width, height)\n *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })\n *   .toFile(output, function(err) {\n *     // Extract a region, resize, then extract from the resized image\n *   });\n *\n * @param {Object} options - describes the region to extract using integral pixel values\n * @param {number} options.left - zero-indexed offset from left edge\n * @param {number} options.top - zero-indexed offset from top edge\n * @param {number} options.width - width of region to extract\n * @param {number} options.height - height of region to extract\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction extract (options) {\n  const suffix = this.options.width === -1 && this.options.height === -1 ? 'Pre' : 'Post';\n  ['left', 'top', 'width', 'height'].forEach(function (name) {\n    const value = options[name];\n    if (is.integer(value) && value >= 0) {\n      this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;\n    } else {\n      throw is.invalidParameterError(name, 'integer', value);\n    }\n  }, this);\n  // Ensure existing rotation occurs before pre-resize extraction\n  if (suffix === 'Pre' && isRotationExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Trim \"boring\" pixels from all edges that contain values similar to the top-left pixel.\n * Images consisting entirely of a single colour will calculate \"boring\" using the alpha channel, if any.\n *\n * The `info` response Object, obtained from callback of `.toFile()` or `.toBuffer()`,\n * will contain `trimOffsetLeft` and `trimOffsetTop` properties.\n *\n * @param {number} [threshold=10] the allowed difference from the top-left pixel, a number greater than zero.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction trim (threshold) {\n  if (!is.defined(threshold)) {\n    this.options.trimThreshold = 10;\n  } else if (is.number(threshold) && threshold > 0) {\n    this.options.trimThreshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'number greater than zero', threshold);\n  }\n  if (this.options.trimThreshold && isRotationExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with resize-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    resize,\n    extend,\n    extract,\n    trim\n  });\n  // Class attributes\n  Sharp.gravity = gravity;\n  Sharp.strategy = strategy;\n  Sharp.kernel = kernel;\n  Sharp.fit = fit;\n  Sharp.position = position;\n};\n"]},"metadata":{},"sourceType":"script"}